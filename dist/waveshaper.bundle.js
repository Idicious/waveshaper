/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!********************************!*\
  !*** ./src/models/interval.js ***!
  \********************************/
/*! exports provided: Interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export Interval */\n/**\r\n * A segment of audio\r\n * \r\n * @export\r\n * @param {string} id \r\n * @param {number} start \r\n * @param {number} end\r\n * @param {number} index\r\n * @param {number} originalStart \r\n * @param {Float32Array} data \r\n */\r\nfunction Interval(id, start, end, index, originalStart, data) {\r\n    this.id = id;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.data = data;\r\n    this.index = index;\r\n    this.originalStart = originalStart;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2RlbHMvaW50ZXJ2YWwuanM/MDVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQSBzZWdtZW50IG9mIGF1ZGlvXHJcbiAqIFxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luYWxTdGFydCBcclxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gSW50ZXJ2YWwoaWQsIHN0YXJ0LCBlbmQsIGluZGV4LCBvcmlnaW5hbFN0YXJ0LCBkYXRhKSB7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLm9yaWdpbmFsU3RhcnQgPSBvcmlnaW5hbFN0YXJ0O1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kZWxzL2ludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!********************************!*\
  !*** ./src/core/waveshaper.js ***!
  \********************************/
/*! exports provided: WaveShaper */
/*! exports used: WaveShaper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = WaveShaper;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaults__ = __webpack_require__(/*! ../defaults */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__strategies_calculate_peak__ = __webpack_require__(/*! ../strategies/calculate/peak */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__strategies_calculate_rms__ = __webpack_require__(/*! ../strategies/calculate/rms */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__strategies_render_double_loop__ = __webpack_require__(/*! ../strategies/render/double-loop */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__models_segment__ = __webpack_require__(/*! ../models/segment */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__methods_flatten__ = __webpack_require__(/*! ../methods/flatten */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__models_interval__ = __webpack_require__(/*! ../models/interval */ 0);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Default constructor \r\n * \r\n * @param {string} id\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {Segment[]} segments \r\n * @param {Interval[]} flattened\r\n */\r\nfunction WaveShaper(id, canvas, segments) {\r\n    this.id = id;\r\n    this.canvas = canvas;\r\n    this.segments = segments;\r\n    this.flatten();\r\n    this.canvas.width = canvas.clientWidth;\r\n    this.canvas.height = canvas.clientHeight;\r\n    this.calculated;\r\n\r\n    this.offScreenCanvas = document.createElement('canvas');\r\n    this.offScreenCanvas.width = this.canvas.width;\r\n    this.offScreenCanvas.height = this.canvas.height;\r\n\r\n    this.width = this.canvas.width;\r\n    this.height = this.canvas.height;\r\n\r\n    this.ctx = canvas.getContext('2d');\r\n    this.offScreenCtx = this.offScreenCanvas.getContext('2d');\r\n}\r\n\r\nWaveShaper.prototype.flatten = function () {\r\n    this.flattened = Object(__WEBPACK_IMPORTED_MODULE_5__methods_flatten__[\"a\" /* flattenSegments */])(this.segments);\r\n}\r\n\r\n/**\r\n * Gets the duration of the audio in seconds\r\n * \r\n * @param {number} samplesPerPixel \r\n * @returns {number} Decimal value of total duration in seconds\r\n */\r\nWaveShaper.prototype.getDuration = function () {\r\n    let maxLength = 0;\r\n    for (let segment of this.segments) {\r\n        const end = segment.start + segment.duration;\r\n        if (end > maxLength) {\r\n            maxLength = end;\r\n        }\r\n    }\r\n    return maxLength;\r\n}\r\n\r\n/**\r\n * Gets the duration of the audio as a date\r\n * \r\n * @param {number} samplesPerPixel \r\n * @returns {Date} Date containing audio length\r\n */\r\nWaveShaper.prototype.getDurationAsDate = function (samplesPerPixel) {\r\n    var date = new Date(0);\r\n    date.setTime(this.getDuration(samplerate) * 1000);\r\n    return date;\r\n}\r\n\r\n/**\r\n * Gets the width of scrollbar needed to scroll through the entire audio file\r\n * \r\n * @param {number} samplesPerPixel \r\n * @param {number} samplerate \r\n * @returns {number} Scroll width in pixels for the entire audio file\r\n */\r\nWaveShaper.prototype.getScrollWidth = function (samplesPerPixel, samplerate) {\r\n    let maxLength = this.getDuration();\r\n    return maxLength * samplerate / samplesPerPixel;\r\n}\r\n\r\nWaveShaper.prototype.lastValues = {\r\n    meterType: null,\r\n    sampleSize: null,\r\n    samplesPerPixel: null,\r\n    scrollPosition: null,\r\n    samplerate: null\r\n}\r\n\r\nWaveShaper.prototype.skipDraw = false;\r\n\r\n/**\r\n * Gets the summerized values for the current settings\r\n * \r\n * @param {string} meterType\r\n * @param {number} sampleSize\r\n * @param {number} samplesPerPixel\r\n * @param {number} scrollPosition\r\n * @param {boolean} forceDraw\r\n * @returns {Array} Two dimensional array, one entry for each pixel, for each pixel a min\r\n * and a max value.\r\n */\r\nWaveShaper.prototype.calculate = function (meterType, sampleSize, samplesPerPixel, scrollPosition, samplerate, forceDraw) {\r\n    if (!forceDraw && this.lastValues.meterType === meterType && this.lastValues.sampleSize === sampleSize &&\r\n        this.lastValues.samplesPerPixel === samplesPerPixel && this.lastValues.scrollPosition === scrollPosition &&\r\n        this.lastValues.samplerate === samplerate) {\r\n\r\n        this.skipDraw = true;\r\n        return this.calculated;\r\n    } else {\r\n        this.skipDraw = false;\r\n        this.lastValues = {\r\n            meterType,\r\n            sampleSize,\r\n            samplesPerPixel,\r\n            scrollPosition,\r\n            samplerate\r\n        }\r\n    }\r\n\r\n    \r\n    switch (meterType) {\r\n        case 'peak':\r\n            this.calculated = Object(__WEBPACK_IMPORTED_MODULE_1__strategies_calculate_peak__[\"a\" /* calculatePeaks */])(\r\n                sampleSize,\r\n                samplesPerPixel,\r\n                this.width,\r\n                this.flattened,\r\n                scrollPosition,\r\n                samplerate\r\n            );\r\n            break;\r\n        default:\r\n            this.calculated = Object(__WEBPACK_IMPORTED_MODULE_2__strategies_calculate_rms__[\"a\" /* calculateRms */])(\r\n                sampleSize,\r\n                samplesPerPixel,\r\n                this.width,\r\n                this.height,\r\n                this.flattened,\r\n                scrollPosition,\r\n                samplerate,\r\n                this.ctx,\r\n                this.offScreenCtx\r\n            );\r\n    }\r\n    \r\n    return this.calculated;\r\n}\r\n\r\n/**\r\n * Draws the waveform to the canvas with current settings\r\n * \r\n * @param {string} drawStyle\r\n */\r\nWaveShaper.prototype.draw = function (drawStyle) {\r\n    if (!this.skipDraw) {\r\n        Object(__WEBPACK_IMPORTED_MODULE_3__strategies_render_double_loop__[\"a\" /* drawDoubleLoop */])(\r\n            this.calculated,\r\n            this.height,\r\n            this.width,\r\n            this.ctx,\r\n            this.offScreenCtx,\r\n            drawStyle\r\n        );\r\n    }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL3dhdmVzaGFwZXIuanM/NzM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgZGVmYXVsdE9wdGlvbnNcclxufSBmcm9tICcuLi9kZWZhdWx0cyc7XHJcbmltcG9ydCB7XHJcbiAgICBjYWxjdWxhdGVQZWFrc1xyXG59IGZyb20gJy4uL3N0cmF0ZWdpZXMvY2FsY3VsYXRlL3BlYWsnXHJcbmltcG9ydCB7XHJcbiAgICBjYWxjdWxhdGVSbXNcclxufSBmcm9tICcuLi9zdHJhdGVnaWVzL2NhbGN1bGF0ZS9ybXMnXHJcbmltcG9ydCB7XHJcbiAgICBkcmF3RG91YmxlTG9vcFxyXG59IGZyb20gJy4uL3N0cmF0ZWdpZXMvcmVuZGVyL2RvdWJsZS1sb29wJztcclxuaW1wb3J0IHtcclxuICAgIFNlZ21lbnRcclxufSBmcm9tICcuLi9tb2RlbHMvc2VnbWVudCc7XHJcbmltcG9ydCB7XHJcbiAgICBmbGF0dGVuU2VnbWVudHNcclxufSBmcm9tICcuLi9tZXRob2RzL2ZsYXR0ZW4nO1xyXG5pbXBvcnQge1xyXG4gICAgSW50ZXJ2YWxcclxufSBmcm9tICcuLi9tb2RlbHMvaW50ZXJ2YWwnO1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgY29uc3RydWN0b3IgXHJcbiAqIFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXHJcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50cyBcclxuICogQHBhcmFtIHtJbnRlcnZhbFtdfSBmbGF0dGVuZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBXYXZlU2hhcGVyKGlkLCBjYW52YXMsIHNlZ21lbnRzKSB7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcclxuICAgIHRoaXMuZmxhdHRlbigpO1xyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xyXG4gICAgdGhpcy5jYWxjdWxhdGVkO1xyXG5cclxuICAgIHRoaXMub2ZmU2NyZWVuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB0aGlzLm9mZlNjcmVlbkNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgdGhpcy5vZmZTY3JlZW5DYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICB0aGlzLm9mZlNjcmVlbkN0eCA9IHRoaXMub2ZmU2NyZWVuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbn1cclxuXHJcbldhdmVTaGFwZXIucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZsYXR0ZW5lZCA9IGZsYXR0ZW5TZWdtZW50cyh0aGlzLnNlZ21lbnRzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpbyBpbiBzZWNvbmRzXHJcbiAqIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlc1BlclBpeGVsIFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBEZWNpbWFsIHZhbHVlIG9mIHRvdGFsIGR1cmF0aW9uIGluIHNlY29uZHNcclxuICovXHJcbldhdmVTaGFwZXIucHJvdG90eXBlLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IG1heExlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBzZWdtZW50IG9mIHRoaXMuc2VnbWVudHMpIHtcclxuICAgICAgICBjb25zdCBlbmQgPSBzZWdtZW50LnN0YXJ0ICsgc2VnbWVudC5kdXJhdGlvbjtcclxuICAgICAgICBpZiAoZW5kID4gbWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1heExlbmd0aCA9IGVuZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF4TGVuZ3RoO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGF1ZGlvIGFzIGEgZGF0ZVxyXG4gKiBcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXNQZXJQaXhlbCBcclxuICogQHJldHVybnMge0RhdGV9IERhdGUgY29udGFpbmluZyBhdWRpbyBsZW5ndGhcclxuICovXHJcbldhdmVTaGFwZXIucHJvdG90eXBlLmdldER1cmF0aW9uQXNEYXRlID0gZnVuY3Rpb24gKHNhbXBsZXNQZXJQaXhlbCkge1xyXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcclxuICAgIGRhdGUuc2V0VGltZSh0aGlzLmdldER1cmF0aW9uKHNhbXBsZXJhdGUpICogMTAwMCk7XHJcbiAgICByZXR1cm4gZGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHdpZHRoIG9mIHNjcm9sbGJhciBuZWVkZWQgdG8gc2Nyb2xsIHRocm91Z2ggdGhlIGVudGlyZSBhdWRpbyBmaWxlXHJcbiAqIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlc1BlclBpeGVsIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcmF0ZSBcclxuICogQHJldHVybnMge251bWJlcn0gU2Nyb2xsIHdpZHRoIGluIHBpeGVscyBmb3IgdGhlIGVudGlyZSBhdWRpbyBmaWxlXHJcbiAqL1xyXG5XYXZlU2hhcGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uIChzYW1wbGVzUGVyUGl4ZWwsIHNhbXBsZXJhdGUpIHtcclxuICAgIGxldCBtYXhMZW5ndGggPSB0aGlzLmdldER1cmF0aW9uKCk7XHJcbiAgICByZXR1cm4gbWF4TGVuZ3RoICogc2FtcGxlcmF0ZSAvIHNhbXBsZXNQZXJQaXhlbDtcclxufVxyXG5cclxuV2F2ZVNoYXBlci5wcm90b3R5cGUubGFzdFZhbHVlcyA9IHtcclxuICAgIG1ldGVyVHlwZTogbnVsbCxcclxuICAgIHNhbXBsZVNpemU6IG51bGwsXHJcbiAgICBzYW1wbGVzUGVyUGl4ZWw6IG51bGwsXHJcbiAgICBzY3JvbGxQb3NpdGlvbjogbnVsbCxcclxuICAgIHNhbXBsZXJhdGU6IG51bGxcclxufVxyXG5cclxuV2F2ZVNoYXBlci5wcm90b3R5cGUuc2tpcERyYXcgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBzdW1tZXJpemVkIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgc2V0dGluZ3NcclxuICogXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRlclR5cGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVNpemVcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXNQZXJQaXhlbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb25cclxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZURyYXdcclxuICogQHJldHVybnMge0FycmF5fSBUd28gZGltZW5zaW9uYWwgYXJyYXksIG9uZSBlbnRyeSBmb3IgZWFjaCBwaXhlbCwgZm9yIGVhY2ggcGl4ZWwgYSBtaW5cclxuICogYW5kIGEgbWF4IHZhbHVlLlxyXG4gKi9cclxuV2F2ZVNoYXBlci5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24gKG1ldGVyVHlwZSwgc2FtcGxlU2l6ZSwgc2FtcGxlc1BlclBpeGVsLCBzY3JvbGxQb3NpdGlvbiwgc2FtcGxlcmF0ZSwgZm9yY2VEcmF3KSB7XHJcbiAgICBpZiAoIWZvcmNlRHJhdyAmJiB0aGlzLmxhc3RWYWx1ZXMubWV0ZXJUeXBlID09PSBtZXRlclR5cGUgJiYgdGhpcy5sYXN0VmFsdWVzLnNhbXBsZVNpemUgPT09IHNhbXBsZVNpemUgJiZcclxuICAgICAgICB0aGlzLmxhc3RWYWx1ZXMuc2FtcGxlc1BlclBpeGVsID09PSBzYW1wbGVzUGVyUGl4ZWwgJiYgdGhpcy5sYXN0VmFsdWVzLnNjcm9sbFBvc2l0aW9uID09PSBzY3JvbGxQb3NpdGlvbiAmJlxyXG4gICAgICAgIHRoaXMubGFzdFZhbHVlcy5zYW1wbGVyYXRlID09PSBzYW1wbGVyYXRlKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2tpcERyYXcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2tpcERyYXcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhc3RWYWx1ZXMgPSB7XHJcbiAgICAgICAgICAgIG1ldGVyVHlwZSxcclxuICAgICAgICAgICAgc2FtcGxlU2l6ZSxcclxuICAgICAgICAgICAgc2FtcGxlc1BlclBpeGVsLFxyXG4gICAgICAgICAgICBzY3JvbGxQb3NpdGlvbixcclxuICAgICAgICAgICAgc2FtcGxlcmF0ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHN3aXRjaCAobWV0ZXJUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAncGVhayc6XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZCA9IGNhbGN1bGF0ZVBlYWtzKFxyXG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSxcclxuICAgICAgICAgICAgICAgIHNhbXBsZXNQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgc2FtcGxlcmF0ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWQgPSBjYWxjdWxhdGVSbXMoXHJcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplLFxyXG4gICAgICAgICAgICAgICAgc2FtcGxlc1BlclBpeGVsLFxyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWQsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIHNhbXBsZXJhdGUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eCxcclxuICAgICAgICAgICAgICAgIHRoaXMub2ZmU2NyZWVuQ3R4XHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyB0aGUgd2F2ZWZvcm0gdG8gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcclxuICogXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkcmF3U3R5bGVcclxuICovXHJcbldhdmVTaGFwZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZHJhd1N0eWxlKSB7XHJcbiAgICBpZiAoIXRoaXMuc2tpcERyYXcpIHtcclxuICAgICAgICBkcmF3RG91YmxlTG9vcChcclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkLFxyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgdGhpcy5jdHgsXHJcbiAgICAgICAgICAgIHRoaXMub2ZmU2NyZWVuQ3R4LFxyXG4gICAgICAgICAgICBkcmF3U3R5bGVcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29yZS93YXZlc2hhcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!*******************************!*\
  !*** ./src/models/segment.js ***!
  \*******************************/
/*! exports provided: Segment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export Segment */\n/**\r\n * A segment of audio\r\n * \r\n * @export\r\n * @param {string} id \r\n * @param {number} start \r\n * @param {number} duration \r\n * @param {number} offsetStart \r\n * @param {number} offsetEnd \r\n * @param {Float32Array} data \r\n * @param {number} index\r\n */\r\nfunction Segment(id, start, duration, offsetStart, offsetEnd, data, index) {\r\n    this.id = id;\r\n    this.start = start;\r\n    this.duration = duration;\r\n    this.offsetStart = offsetStart;\r\n    this.offsetEnd = offsetEnd;\r\n    this.data = data;\r\n    this.index = index;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2RlbHMvc2VnbWVudC5qcz83MzhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIHNlZ21lbnQgb2YgYXVkaW9cclxuICogXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFN0YXJ0IFxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0RW5kIFxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VnbWVudChpZCwgc3RhcnQsIGR1cmF0aW9uLCBvZmZzZXRTdGFydCwgb2Zmc2V0RW5kLCBkYXRhLCBpbmRleCkge1xyXG4gICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgdGhpcy5vZmZzZXRTdGFydCA9IG9mZnNldFN0YXJ0O1xyXG4gICAgdGhpcy5vZmZzZXRFbmQgPSBvZmZzZXRFbmQ7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbW9kZWxzL3NlZ21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/*! exports provided: defaultOptions */
/*! exports used: defaultOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("const defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 1,\r\n    drawStyle: 'fill',\r\n    meterType: 'rms'\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = defaultOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kZWZhdWx0cy5qcz82NmQ4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIHNjcm9sbFBvc2l0aW9uOiAwLFxyXG4gICAgc2FtcGxlc1BlclBpeGVsOiAxMDI0LFxyXG4gICAgcmVzb2x1dGlvbjogMSxcclxuICAgIGRyYXdTdHlsZTogJ2ZpbGwnLFxyXG4gICAgbWV0ZXJUeXBlOiAncm1zJ1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGVmYXVsdHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!*****************************!*\
  !*** ./src/core/manager.js ***!
  \*****************************/
/*! exports provided: WaveShapeManager */
/*! exports used: WaveShapeManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__waveshaper__ = __webpack_require__(/*! ./waveshaper */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_segment__ = __webpack_require__(/*! ../models/segment */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__defaults__ = __webpack_require__(/*! ../defaults */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_hamsters_js__ = __webpack_require__(/*! hamsters.js */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_hamsters_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_hamsters_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__interaction_drag__ = __webpack_require__(/*! ../interaction/drag */ 13);\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * \r\n * @export\r\n */\r\nclass WaveShapeManager {\r\n\r\n    /**\r\n     * Map of waveshapers managed by the manager\r\n     * \r\n     * @type {Map<string, WaveShaper>}\r\n     * @readonly\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get waveShapers(){ return this._waveShapers; }\r\n\r\n    /**\r\n     * @description Audio samplerate\r\n     * \r\n     * @returns {number}\r\n     * @readonly\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get samplerate() { return this._samplerate; }\r\n\r\n    /**\r\n     * @description Sample range per pixel, zoom level\r\n     * @example Lower value to zoom in, increase to zoom out\r\n     * \r\n     * @param {number}\r\n     * @returns {number}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get samplesPerPixel() { return this._samplesPerPixel; }\r\n    set samplesPerPixel(spp) { this._samplesPerPixel = spp; }\r\n\r\n    /**\r\n     * @description Sample size per pixel, determines accuracy\r\n     * @example Lower value to decrease accuracy and increase performance\r\n     * \r\n     * @param {number}\r\n     * @returns {number}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get resolution() { return this._resolution; }\r\n    set resolution(res) { this._resolution = res; }\r\n\r\n    /**\r\n     * @description Virtual scrolling is used, changing this value pans the waveform\r\n     * \r\n     * @param {number}\r\n     * @returns {number}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get scrollPosition() { return this._scrollPosition; }\r\n    set scrollPosition(position) { this._scrollPosition = position; }\r\n\r\n    /**\r\n     * @description Draw style of waveform, either filled or stroked\r\n     * \r\n     * @param {'stroke' | 'fill'}\r\n     * @returns {'stroke' | 'fill'}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get drawStyle() { return this._drawStyle; }\r\n    set drawStyle(style) { this._drawStyle = style; }\r\n\r\n    /**\r\n     * @description Calculation method used to determine value of sample range\r\n     * @example Peak get the peak values of the range, RMS is similar to average https://en.wikipedia.org/wiki/Root_mean_square\r\n     * \r\n     * @param {'peak' | 'rms'}\r\n     * @returns {'peak' | 'rms'}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get meterType() { return this._meterType; }\r\n    set meterType(type) { this._meterType = type; }\r\n\r\n    /**\r\n     * @description Set at start of an interaction, null when interaction is complete\r\n     * \r\n     * @param {Segment} segment Currently active segment\r\n     * @returns {Segment}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get activeSegment() { return this._activeSegment; }\r\n    set activeSegment(segment) { this._activeSegment = segment; }\r\n\r\n    /**\r\n     * @description Set at start of an interaction, null when interaction is complete\r\n     * \r\n     * @param {number} start Start time of Segment at beginning of interaction\r\n     * @returns {number}\r\n     * @memberof WaveShapeManager\r\n     */\r\n    get activeSegmentStart() { return this._activeSegmentStart; }\r\n    set activeSegmentStart(start) { this._activeSegmentStart = start; }\r\n\r\n    /**\r\n     * @param {number} samplerate Audio samplerate\r\n     * @param {defaultOptions} [options=defaultOptions] Initial options\r\n     * @throws {Error} Throws an error if samplerate is null or NaN\r\n     * @constructor \r\n     */\r\n    constructor(samplerate, options = __WEBPACK_IMPORTED_MODULE_2__defaults__[\"a\" /* defaultOptions */]) {\r\n        if(samplerate == null || isNaN(samplerate)) {\r\n            throw new Error('samplerate cannot be null and must be a number');\r\n        }\r\n\r\n        this._waveShapers = new Map();\r\n        this._samplerate = samplerate;\r\n    \r\n        this._resolution = options.resolution;\r\n        this._samplesPerPixel = options.samplesPerPixel;\r\n        this._scrollPosition = options.scrollPosition;\r\n        this._drawStyle = options.drawStyle;\r\n        this._meterType = options.meterType;\r\n    }\r\n    \r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     * \r\n     * @param {string} id\r\n     * @param {HTMLCanvasElement} canvas Html canvas element\r\n     * @param {Segment[]} segments \r\n     * @memberof WaveShapeManager\r\n     */\r\n    addWave(id, canvas, segments) {\r\n        const wave = new __WEBPACK_IMPORTED_MODULE_0__waveshaper__[\"a\" /* WaveShaper */](id, canvas, segments);\r\n        this.waveShapers.set(id, wave);\r\n        \r\n        Object(__WEBPACK_IMPORTED_MODULE_4__interaction_drag__[\"a\" /* setupDrag */])(wave, this);\r\n    }\r\n\r\n    /**\r\n     * @description Removes the wave with given id from the manager\r\n     * \r\n     * @param {string} id \r\n     * @memberof WaveShapeManager\r\n     */\r\n    removeWave(id) {\r\n        this.waveShapers.delete(id);\r\n    }\r\n\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     * \r\n     * @param {string} id \r\n     * @memberof WaveShapeManager\r\n     */\r\n    flatten(id) {\r\n        this.waveShapers.get(id).flatten();\r\n    }\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = WaveShapeManager;\n\r\n\r\n/**\r\n * Gets the duration of the audio in seconds\r\n * \r\n * @returns {number} Decimal value of total duration in seconds\r\n */\r\nWaveShapeManager.prototype.getDuration = function () {\r\n    var maxDuration = 0;\r\n    for (var wave of this.waveShapers.values()) {\r\n        var duration = wave.getDuration(this.samplesPerPixel);\r\n        if (duration > maxDuration) {\r\n            maxDuration = duration;\r\n        }\r\n    }\r\n    return maxDuration;\r\n}\r\n\r\n/**\r\n * Gets the duration of the audio as a date\r\n * \r\n * @returns {Date} Date containing audio length\r\n */\r\nWaveShapeManager.prototype.getDurationAsDate = function () {\r\n    var date = new Date(0);\r\n    date.setTime(this.getDuration() * 1000);\r\n    return date;\r\n}\r\n\r\n/**\r\n * Gets the width of scrollbar needed to scroll through the entire audio file\r\n * \r\n * @returns {number} Scroll width in pixels for the entire audio file\r\n */\r\nWaveShapeManager.prototype.getScrollWidth = function () {\r\n    var maxWidth = 0;\r\n    for (var wave of this.waveShapers.values()) {\r\n        const width = wave.getScrollWidth(this.samplesPerPixel, this.samplerate);\r\n        if (width > maxWidth) {\r\n            maxWidth = width;\r\n        }\r\n    }\r\n\r\n    return maxWidth;\r\n}\r\n\r\n/**\r\n * Draws the waveform to the canvas with current settings\r\n * \r\n * @param {string[]} ids Options array of id's to draw\r\n * @param {boolean} forceDraw Force redraw of the given waves\r\n */\r\nWaveShapeManager.prototype.draw = function (ids, forceDraw) {\r\n    const idsToDraw = ids == null ? this.waveShapers.keys() : ids;\r\n    for (var id of idsToDraw) {\r\n        var wave = this.waveShapers.get(id);\r\n        wave.calculate(\r\n            this.meterType, \r\n            this.resolution, \r\n            this.samplesPerPixel, \r\n            this.scrollPosition,\r\n            this.samplerate,\r\n            forceDraw\r\n        );\r\n    }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL21hbmFnZXIuanM/NDlhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXYXZlU2hhcGVyIH0gZnJvbSAnLi93YXZlc2hhcGVyJztcclxuaW1wb3J0IHsgU2VnbWVudCB9IGZyb20gJy4uL21vZGVscy9zZWdtZW50JztcclxuaW1wb3J0IHsgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuLi9kZWZhdWx0cyc7XHJcbmltcG9ydCB7IGhhbXN0ZXJzIH0gZnJvbSAnaGFtc3RlcnMuanMnO1xyXG5pbXBvcnQgeyBzZXR1cERyYWcgfSBmcm9tICcuLi9pbnRlcmFjdGlvbi9kcmFnJztcclxuXHJcbi8qKlxyXG4gKiBcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdhdmVTaGFwZU1hbmFnZXIge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIHdhdmVzaGFwZXJzIG1hbmFnZWQgYnkgdGhlIG1hbmFnZXJcclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIFdhdmVTaGFwZXI+fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXQgd2F2ZVNoYXBlcnMoKXsgcmV0dXJuIHRoaXMuX3dhdmVTaGFwZXJzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQXVkaW8gc2FtcGxlcmF0ZVxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXQgc2FtcGxlcmF0ZSgpIHsgcmV0dXJuIHRoaXMuX3NhbXBsZXJhdGU7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBTYW1wbGUgcmFuZ2UgcGVyIHBpeGVsLCB6b29tIGxldmVsXHJcbiAgICAgKiBAZXhhbXBsZSBMb3dlciB2YWx1ZSB0byB6b29tIGluLCBpbmNyZWFzZSB0byB6b29tIG91dFxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn1cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXQgc2FtcGxlc1BlclBpeGVsKCkgeyByZXR1cm4gdGhpcy5fc2FtcGxlc1BlclBpeGVsOyB9XHJcbiAgICBzZXQgc2FtcGxlc1BlclBpeGVsKHNwcCkgeyB0aGlzLl9zYW1wbGVzUGVyUGl4ZWwgPSBzcHA7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBTYW1wbGUgc2l6ZSBwZXIgcGl4ZWwsIGRldGVybWluZXMgYWNjdXJhY3lcclxuICAgICAqIEBleGFtcGxlIExvd2VyIHZhbHVlIHRvIGRlY3JlYXNlIGFjY3VyYWN5IGFuZCBpbmNyZWFzZSBwZXJmb3JtYW5jZVxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn1cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXQgcmVzb2x1dGlvbigpIHsgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb247IH1cclxuICAgIHNldCByZXNvbHV0aW9uKHJlcykgeyB0aGlzLl9yZXNvbHV0aW9uID0gcmVzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVmlydHVhbCBzY3JvbGxpbmcgaXMgdXNlZCwgY2hhbmdpbmcgdGhpcyB2YWx1ZSBwYW5zIHRoZSB3YXZlZm9ybVxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn1cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXQgc2Nyb2xsUG9zaXRpb24oKSB7IHJldHVybiB0aGlzLl9zY3JvbGxQb3NpdGlvbjsgfVxyXG4gICAgc2V0IHNjcm9sbFBvc2l0aW9uKHBvc2l0aW9uKSB7IHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gcG9zaXRpb247IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBEcmF3IHN0eWxlIG9mIHdhdmVmb3JtLCBlaXRoZXIgZmlsbGVkIG9yIHN0cm9rZWRcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHsnc3Ryb2tlJyB8ICdmaWxsJ31cclxuICAgICAqIEByZXR1cm5zIHsnc3Ryb2tlJyB8ICdmaWxsJ31cclxuICAgICAqIEBtZW1iZXJvZiBXYXZlU2hhcGVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldCBkcmF3U3R5bGUoKSB7IHJldHVybiB0aGlzLl9kcmF3U3R5bGU7IH1cclxuICAgIHNldCBkcmF3U3R5bGUoc3R5bGUpIHsgdGhpcy5fZHJhd1N0eWxlID0gc3R5bGU7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxjdWxhdGlvbiBtZXRob2QgdXNlZCB0byBkZXRlcm1pbmUgdmFsdWUgb2Ygc2FtcGxlIHJhbmdlXHJcbiAgICAgKiBAZXhhbXBsZSBQZWFrIGdldCB0aGUgcGVhayB2YWx1ZXMgb2YgdGhlIHJhbmdlLCBSTVMgaXMgc2ltaWxhciB0byBhdmVyYWdlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvb3RfbWVhbl9zcXVhcmVcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHsncGVhaycgfCAncm1zJ31cclxuICAgICAqIEByZXR1cm5zIHsncGVhaycgfCAncm1zJ31cclxuICAgICAqIEBtZW1iZXJvZiBXYXZlU2hhcGVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldCBtZXRlclR5cGUoKSB7IHJldHVybiB0aGlzLl9tZXRlclR5cGU7IH1cclxuICAgIHNldCBtZXRlclR5cGUodHlwZSkgeyB0aGlzLl9tZXRlclR5cGUgPSB0eXBlOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IGF0IHN0YXJ0IG9mIGFuIGludGVyYWN0aW9uLCBudWxsIHdoZW4gaW50ZXJhY3Rpb24gaXMgY29tcGxldGVcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTZWdtZW50fSBzZWdtZW50IEN1cnJlbnRseSBhY3RpdmUgc2VnbWVudFxyXG4gICAgICogQHJldHVybnMge1NlZ21lbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXQgYWN0aXZlU2VnbWVudCgpIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZVNlZ21lbnQ7IH1cclxuICAgIHNldCBhY3RpdmVTZWdtZW50KHNlZ21lbnQpIHsgdGhpcy5fYWN0aXZlU2VnbWVudCA9IHNlZ21lbnQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYXQgc3RhcnQgb2YgYW4gaW50ZXJhY3Rpb24sIG51bGwgd2hlbiBpbnRlcmFjdGlvbiBpcyBjb21wbGV0ZVxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgdGltZSBvZiBTZWdtZW50IGF0IGJlZ2lubmluZyBvZiBpbnRlcmFjdGlvblxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBXYXZlU2hhcGVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldCBhY3RpdmVTZWdtZW50U3RhcnQoKSB7IHJldHVybiB0aGlzLl9hY3RpdmVTZWdtZW50U3RhcnQ7IH1cclxuICAgIHNldCBhY3RpdmVTZWdtZW50U3RhcnQoc3RhcnQpIHsgdGhpcy5fYWN0aXZlU2VnbWVudFN0YXJ0ID0gc3RhcnQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVyYXRlIEF1ZGlvIHNhbXBsZXJhdGVcclxuICAgICAqIEBwYXJhbSB7ZGVmYXVsdE9wdGlvbnN9IFtvcHRpb25zPWRlZmF1bHRPcHRpb25zXSBJbml0aWFsIG9wdGlvbnNcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgc2FtcGxlcmF0ZSBpcyBudWxsIG9yIE5hTlxyXG4gICAgICogQGNvbnN0cnVjdG9yIFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzYW1wbGVyYXRlLCBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICBpZihzYW1wbGVyYXRlID09IG51bGwgfHwgaXNOYU4oc2FtcGxlcmF0ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYW1wbGVyYXRlIGNhbm5vdCBiZSBudWxsIGFuZCBtdXN0IGJlIGEgbnVtYmVyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl93YXZlU2hhcGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9zYW1wbGVyYXRlID0gc2FtcGxlcmF0ZTtcclxuICAgIFxyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5fc2FtcGxlc1BlclBpeGVsID0gb3B0aW9ucy5zYW1wbGVzUGVyUGl4ZWw7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSBvcHRpb25zLnNjcm9sbFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuX2RyYXdTdHlsZSA9IG9wdGlvbnMuZHJhd1N0eWxlO1xyXG4gICAgICAgIHRoaXMuX21ldGVyVHlwZSA9IG9wdGlvbnMubWV0ZXJUeXBlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGRzIGEgd2F2ZXNoYXBlciB0byB0aGUgbWFuYWdlclxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBIdG1sIGNhbnZhcyBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHMgXHJcbiAgICAgKiBAbWVtYmVyb2YgV2F2ZVNoYXBlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBhZGRXYXZlKGlkLCBjYW52YXMsIHNlZ21lbnRzKSB7XHJcbiAgICAgICAgY29uc3Qgd2F2ZSA9IG5ldyBXYXZlU2hhcGVyKGlkLCBjYW52YXMsIHNlZ21lbnRzKTtcclxuICAgICAgICB0aGlzLndhdmVTaGFwZXJzLnNldChpZCwgd2F2ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0dXBEcmFnKHdhdmUsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgdGhlIHdhdmUgd2l0aCBnaXZlbiBpZCBmcm9tIHRoZSBtYW5hZ2VyXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcclxuICAgICAqIEBtZW1iZXJvZiBXYXZlU2hhcGVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVdhdmUoaWQpIHtcclxuICAgICAgICB0aGlzLndhdmVTaGFwZXJzLmRlbGV0ZShpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRmxhdHRlbnMgdGhlIHNlZ21lbnRzIG9mIHRoZSBnaXZlbiB3YXZlc2hhcGVyIGlkXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcclxuICAgICAqIEBtZW1iZXJvZiBXYXZlU2hhcGVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGZsYXR0ZW4oaWQpIHtcclxuICAgICAgICB0aGlzLndhdmVTaGFwZXJzLmdldChpZCkuZmxhdHRlbigpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGF1ZGlvIGluIHNlY29uZHNcclxuICogXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IERlY2ltYWwgdmFsdWUgb2YgdG90YWwgZHVyYXRpb24gaW4gc2Vjb25kc1xyXG4gKi9cclxuV2F2ZVNoYXBlTWFuYWdlci5wcm90b3R5cGUuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWF4RHVyYXRpb24gPSAwO1xyXG4gICAgZm9yICh2YXIgd2F2ZSBvZiB0aGlzLndhdmVTaGFwZXJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gd2F2ZS5nZXREdXJhdGlvbih0aGlzLnNhbXBsZXNQZXJQaXhlbCk7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uID4gbWF4RHVyYXRpb24pIHtcclxuICAgICAgICAgICAgbWF4RHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF4RHVyYXRpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8gYXMgYSBkYXRlXHJcbiAqIFxyXG4gKiBAcmV0dXJucyB7RGF0ZX0gRGF0ZSBjb250YWluaW5nIGF1ZGlvIGxlbmd0aFxyXG4gKi9cclxuV2F2ZVNoYXBlTWFuYWdlci5wcm90b3R5cGUuZ2V0RHVyYXRpb25Bc0RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xyXG4gICAgZGF0ZS5zZXRUaW1lKHRoaXMuZ2V0RHVyYXRpb24oKSAqIDEwMDApO1xyXG4gICAgcmV0dXJuIGRhdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB3aWR0aCBvZiBzY3JvbGxiYXIgbmVlZGVkIHRvIHNjcm9sbCB0aHJvdWdoIHRoZSBlbnRpcmUgYXVkaW8gZmlsZVxyXG4gKiBcclxuICogQHJldHVybnMge251bWJlcn0gU2Nyb2xsIHdpZHRoIGluIHBpeGVscyBmb3IgdGhlIGVudGlyZSBhdWRpbyBmaWxlXHJcbiAqL1xyXG5XYXZlU2hhcGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtYXhXaWR0aCA9IDA7XHJcbiAgICBmb3IgKHZhciB3YXZlIG9mIHRoaXMud2F2ZVNoYXBlcnMudmFsdWVzKCkpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHdhdmUuZ2V0U2Nyb2xsV2lkdGgodGhpcy5zYW1wbGVzUGVyUGl4ZWwsIHRoaXMuc2FtcGxlcmF0ZSk7XHJcbiAgICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSB3aWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1heFdpZHRoO1xyXG59XHJcblxyXG4vKipcclxuICogRHJhd3MgdGhlIHdhdmVmb3JtIHRvIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHNldHRpbmdzXHJcbiAqIFxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBpZHMgT3B0aW9ucyBhcnJheSBvZiBpZCdzIHRvIGRyYXdcclxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZURyYXcgRm9yY2UgcmVkcmF3IG9mIHRoZSBnaXZlbiB3YXZlc1xyXG4gKi9cclxuV2F2ZVNoYXBlTWFuYWdlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChpZHMsIGZvcmNlRHJhdykge1xyXG4gICAgY29uc3QgaWRzVG9EcmF3ID0gaWRzID09IG51bGwgPyB0aGlzLndhdmVTaGFwZXJzLmtleXMoKSA6IGlkcztcclxuICAgIGZvciAodmFyIGlkIG9mIGlkc1RvRHJhdykge1xyXG4gICAgICAgIHZhciB3YXZlID0gdGhpcy53YXZlU2hhcGVycy5nZXQoaWQpO1xyXG4gICAgICAgIHdhdmUuY2FsY3VsYXRlKFxyXG4gICAgICAgICAgICB0aGlzLm1ldGVyVHlwZSwgXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiwgXHJcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlc1BlclBpeGVsLCBcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbixcclxuICAgICAgICAgICAgdGhpcy5zYW1wbGVyYXRlLFxyXG4gICAgICAgICAgICBmb3JjZURyYXdcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29yZS9tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: WaveShaper, WaveShapeManager, Schedular */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_core_waveshaper__ = __webpack_require__(/*! ./src/core/waveshaper */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_core_manager__ = __webpack_require__(/*! ./src/core/manager */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_schedular_schedular__ = __webpack_require__(/*! ./src/schedular/schedular */ 15);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"WaveShaper\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_waveshaper__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"WaveShapeManager\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_core_manager__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Schedular\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_schedular_schedular__[\"a\"]; });\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nwindow[\"WaveShaper\"] = __WEBPACK_IMPORTED_MODULE_0__src_core_waveshaper__[\"a\" /* WaveShaper */];\r\nwindow[\"WaveShapeManager\"] = __WEBPACK_IMPORTED_MODULE_1__src_core_manager__[\"a\" /* WaveShapeManager */];\r\nwindow[\"Schedular\"] = __WEBPACK_IMPORTED_MODULE_2__src_schedular_schedular__[\"a\" /* Schedular */];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzI2NDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2F2ZVNoYXBlciB9IGZyb20gXCIuL3NyYy9jb3JlL3dhdmVzaGFwZXJcIjtcclxuaW1wb3J0IHsgV2F2ZVNoYXBlTWFuYWdlciB9IGZyb20gXCIuL3NyYy9jb3JlL21hbmFnZXJcIjtcclxuaW1wb3J0IHsgU2NoZWR1bGFyIH0gZnJvbSAnLi9zcmMvc2NoZWR1bGFyL3NjaGVkdWxhcic7XHJcblxyXG5leHBvcnQgeyBXYXZlU2hhcGVyIH07XHJcbmV4cG9ydCB7IFdhdmVTaGFwZU1hbmFnZXIgfTtcclxuZXhwb3J0IHsgU2NoZWR1bGFyIH07XHJcblxyXG53aW5kb3dbXCJXYXZlU2hhcGVyXCJdID0gV2F2ZVNoYXBlcjtcclxud2luZG93W1wiV2F2ZVNoYXBlTWFuYWdlclwiXSA9IFdhdmVTaGFwZU1hbmFnZXI7XHJcbndpbmRvd1tcIlNjaGVkdWxhclwiXSA9IFNjaGVkdWxhcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!******************************************!*\
  !*** ./src/strategies/calculate/peak.js ***!
  \******************************************/
/*! exports provided: calculatePeaks */
/*! exports used: calculatePeaks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = calculatePeaks;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_interval__ = __webpack_require__(/*! ../../models/interval */ 0);\n\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param {number} sampleRatio \r\n * @param {number} samplesPerPixel \r\n * @param {number} width \r\n * @param {Interval[]} segments \r\n * @param {number} scrollPosition \r\n * @param {number} sampleRate\r\n * @returns \r\n */\r\nfunction calculatePeaks(sampleRatio, samplesPerPixel, width, segments, scrollPosition, sampleRate) {\r\n    const sampleSize = Math.max(1, samplesPerPixel / sampleRatio);\r\n    const start = scrollPosition * samplesPerPixel;\r\n    const startSecond = start / sampleRate;\r\n\r\n    const vals = [];\r\n\r\n    // For each pixel we display\r\n    for (let i = 0; i < width; i++) {\r\n        let posMax = 0;\r\n        let negMax = 0;\r\n\r\n        const currentSecond = startSecond + ((i * samplesPerPixel) / sampleRate);\r\n        const interval = segments.find(s => s.start <= currentSecond && s.end >= currentSecond);\r\n\r\n        if(interval == null) {\r\n            vals.push([negMax, posMax]);\r\n            continue;\r\n        }\r\n\r\n        const offsetStart = interval.start - interval.originalStart;\r\n        const secondsIntoInterval = currentSecond - interval.start;\r\n        const startSample = Math.floor(((secondsIntoInterval + offsetStart) * sampleRate));\r\n\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more tha n sampleSize frames per pixel.\r\n        for (let j = 0; j < samplesPerPixel; j += sampleSize) {\r\n            const index = j + startSample;\r\n            if (index < interval.data.length) {\r\n                const val = interval.data[index];\r\n\r\n                // Keep track of positive and negative values separately\r\n                if (val > 0 && val > posMax) {\r\n                    posMax = val;\r\n                } else if (val < negMax) {\r\n                    negMax = val;\r\n                }\r\n            }\r\n        }\r\n        vals.push([negMax, posMax]);\r\n    }\r\n    return vals;\r\n}\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param {number} sampleRatio \r\n * @param {number} samplesPerPixel \r\n * @param {number} width \r\n * @param {Interval[]} segments \r\n * @param {number} scrollPosition \r\n * @param {number} sampleRate\r\n * @returns \r\n */\r\n// export function calculatePeaks2(sampleRatio, samplesPerPixel, width, segments, scrollPosition, sampleRate) {\r\n//     const sampleSize = Math.max(1, samplesPerPixel / sampleRatio);\r\n//     const start = scrollPosition * samplesPerPixel;\r\n//     const startSecond = start / sampleRate;\r\n//     const endSecond = startSecond + (width * samplesPerPixel / sampleRate);\r\n\r\n//     const intervals = segments.filter(s => s.start <= endSecond && s.end >= startSecond);\r\n//     const vals = [];\r\n\r\n//     for(let interval of intervals) {\r\n//         const startPixel = Math.floor(Math.max(interval.start - startSecond, 0) * sampleRate / samplesPerPixel);\r\n//         const endPixel = startPixel + ((interval.end - interval.start) * sampleRate / samplesPerPixel);\r\n//     }\r\n\r\n//     // For each pixel we display\r\n//     for (let i = 0; i < width; i++) {\r\n//         let posMax = 0;\r\n//         let negMax = 0;\r\n\r\n//         const currentSecond = startSecond + ((i * samplesPerPixel) / sampleRate);\r\n//         const interval = segments.find(s => s.start <= currentSecond && s.end >= currentSecond);\r\n\r\n//         if(interval == null) {\r\n//             vals.push([negMax, posMax]);\r\n//             continue;\r\n//         }\r\n\r\n//         const startSample = Math.floor(((startSecond - interval.originalStart) * sampleRate) + (i * samplesPerPixel));\r\n\r\n//         // Cycle through the data-points relevant to the pixel\r\n//         // Don't cycle through more tha n sampleSize frames per pixel.\r\n//         for (let j = 0; j < samplesPerPixel; j += sampleSize) {\r\n//             const index = j + startSample;\r\n//             if (index < interval.data.length) {\r\n//                 const val = interval.data[index];\r\n\r\n//                 // Keep track of positive and negative values separately\r\n//                 if (val > 0 && val > posMax) {\r\n//                     posMax = val;\r\n//                 } else if (val < negMax) {\r\n//                     negMax = val;\r\n//                 }\r\n//             }\r\n//         }\r\n//         vals.push([negMax, posMax]);\r\n//     }\r\n//     return vals;\r\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHJhdGVnaWVzL2NhbGN1bGF0ZS9wZWFrLmpzP2YyMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50ZXJ2YWwgfSBmcm9tICcuLi8uLi9tb2RlbHMvaW50ZXJ2YWwnO1xyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0aW8gXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzUGVyUGl4ZWwgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBcclxuICogQHBhcmFtIHtJbnRlcnZhbFtdfSBzZWdtZW50cyBcclxuICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0ZVxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQZWFrcyhzYW1wbGVSYXRpbywgc2FtcGxlc1BlclBpeGVsLCB3aWR0aCwgc2VnbWVudHMsIHNjcm9sbFBvc2l0aW9uLCBzYW1wbGVSYXRlKSB7XHJcbiAgICBjb25zdCBzYW1wbGVTaXplID0gTWF0aC5tYXgoMSwgc2FtcGxlc1BlclBpeGVsIC8gc2FtcGxlUmF0aW8pO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBzY3JvbGxQb3NpdGlvbiAqIHNhbXBsZXNQZXJQaXhlbDtcclxuICAgIGNvbnN0IHN0YXJ0U2Vjb25kID0gc3RhcnQgLyBzYW1wbGVSYXRlO1xyXG5cclxuICAgIGNvbnN0IHZhbHMgPSBbXTtcclxuXHJcbiAgICAvLyBGb3IgZWFjaCBwaXhlbCB3ZSBkaXNwbGF5XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICBsZXQgcG9zTWF4ID0gMDtcclxuICAgICAgICBsZXQgbmVnTWF4ID0gMDtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFNlY29uZCA9IHN0YXJ0U2Vjb25kICsgKChpICogc2FtcGxlc1BlclBpeGVsKSAvIHNhbXBsZVJhdGUpO1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2VnbWVudHMuZmluZChzID0+IHMuc3RhcnQgPD0gY3VycmVudFNlY29uZCAmJiBzLmVuZCA+PSBjdXJyZW50U2Vjb25kKTtcclxuXHJcbiAgICAgICAgaWYoaW50ZXJ2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWxzLnB1c2goW25lZ01heCwgcG9zTWF4XSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSBpbnRlcnZhbC5zdGFydCAtIGludGVydmFsLm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kc0ludG9JbnRlcnZhbCA9IGN1cnJlbnRTZWNvbmQgLSBpbnRlcnZhbC5zdGFydDtcclxuICAgICAgICBjb25zdCBzdGFydFNhbXBsZSA9IE1hdGguZmxvb3IoKChzZWNvbmRzSW50b0ludGVydmFsICsgb2Zmc2V0U3RhcnQpICogc2FtcGxlUmF0ZSkpO1xyXG5cclxuICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRoZSBkYXRhLXBvaW50cyByZWxldmFudCB0byB0aGUgcGl4ZWxcclxuICAgICAgICAvLyBEb24ndCBjeWNsZSB0aHJvdWdoIG1vcmUgdGhhIG4gc2FtcGxlU2l6ZSBmcmFtZXMgcGVyIHBpeGVsLlxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2FtcGxlc1BlclBpeGVsOyBqICs9IHNhbXBsZVNpemUpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBqICsgc3RhcnRTYW1wbGU7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGludGVydmFsLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBpbnRlcnZhbC5kYXRhW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgc2VwYXJhdGVseVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IDAgJiYgdmFsID4gcG9zTWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zTWF4ID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPCBuZWdNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWdNYXggPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFscy5wdXNoKFtuZWdNYXgsIHBvc01heF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBcclxuICogXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVJhdGlvIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlc1BlclBpeGVsIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggXHJcbiAqIEBwYXJhbSB7SW50ZXJ2YWxbXX0gc2VnbWVudHMgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxQb3NpdGlvbiBcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVJhdGVcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG4vLyBleHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGVha3MyKHNhbXBsZVJhdGlvLCBzYW1wbGVzUGVyUGl4ZWwsIHdpZHRoLCBzZWdtZW50cywgc2Nyb2xsUG9zaXRpb24sIHNhbXBsZVJhdGUpIHtcclxuLy8gICAgIGNvbnN0IHNhbXBsZVNpemUgPSBNYXRoLm1heCgxLCBzYW1wbGVzUGVyUGl4ZWwgLyBzYW1wbGVSYXRpbyk7XHJcbi8vICAgICBjb25zdCBzdGFydCA9IHNjcm9sbFBvc2l0aW9uICogc2FtcGxlc1BlclBpeGVsO1xyXG4vLyAgICAgY29uc3Qgc3RhcnRTZWNvbmQgPSBzdGFydCAvIHNhbXBsZVJhdGU7XHJcbi8vICAgICBjb25zdCBlbmRTZWNvbmQgPSBzdGFydFNlY29uZCArICh3aWR0aCAqIHNhbXBsZXNQZXJQaXhlbCAvIHNhbXBsZVJhdGUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGludGVydmFscyA9IHNlZ21lbnRzLmZpbHRlcihzID0+IHMuc3RhcnQgPD0gZW5kU2Vjb25kICYmIHMuZW5kID49IHN0YXJ0U2Vjb25kKTtcclxuLy8gICAgIGNvbnN0IHZhbHMgPSBbXTtcclxuXHJcbi8vICAgICBmb3IobGV0IGludGVydmFsIG9mIGludGVydmFscykge1xyXG4vLyAgICAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSBNYXRoLmZsb29yKE1hdGgubWF4KGludGVydmFsLnN0YXJ0IC0gc3RhcnRTZWNvbmQsIDApICogc2FtcGxlUmF0ZSAvIHNhbXBsZXNQZXJQaXhlbCk7XHJcbi8vICAgICAgICAgY29uc3QgZW5kUGl4ZWwgPSBzdGFydFBpeGVsICsgKChpbnRlcnZhbC5lbmQgLSBpbnRlcnZhbC5zdGFydCkgKiBzYW1wbGVSYXRlIC8gc2FtcGxlc1BlclBpeGVsKTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICAvLyBGb3IgZWFjaCBwaXhlbCB3ZSBkaXNwbGF5XHJcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuLy8gICAgICAgICBsZXQgcG9zTWF4ID0gMDtcclxuLy8gICAgICAgICBsZXQgbmVnTWF4ID0gMDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgY3VycmVudFNlY29uZCA9IHN0YXJ0U2Vjb25kICsgKChpICogc2FtcGxlc1BlclBpeGVsKSAvIHNhbXBsZVJhdGUpO1xyXG4vLyAgICAgICAgIGNvbnN0IGludGVydmFsID0gc2VnbWVudHMuZmluZChzID0+IHMuc3RhcnQgPD0gY3VycmVudFNlY29uZCAmJiBzLmVuZCA+PSBjdXJyZW50U2Vjb25kKTtcclxuXHJcbi8vICAgICAgICAgaWYoaW50ZXJ2YWwgPT0gbnVsbCkge1xyXG4vLyAgICAgICAgICAgICB2YWxzLnB1c2goW25lZ01heCwgcG9zTWF4XSk7XHJcbi8vICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgY29uc3Qgc3RhcnRTYW1wbGUgPSBNYXRoLmZsb29yKCgoc3RhcnRTZWNvbmQgLSBpbnRlcnZhbC5vcmlnaW5hbFN0YXJ0KSAqIHNhbXBsZVJhdGUpICsgKGkgKiBzYW1wbGVzUGVyUGl4ZWwpKTtcclxuXHJcbi8vICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCB0aGUgZGF0YS1wb2ludHMgcmVsZXZhbnQgdG8gdGhlIHBpeGVsXHJcbi8vICAgICAgICAgLy8gRG9uJ3QgY3ljbGUgdGhyb3VnaCBtb3JlIHRoYSBuIHNhbXBsZVNpemUgZnJhbWVzIHBlciBwaXhlbC5cclxuLy8gICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNhbXBsZXNQZXJQaXhlbDsgaiArPSBzYW1wbGVTaXplKSB7XHJcbi8vICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaiArIHN0YXJ0U2FtcGxlO1xyXG4vLyAgICAgICAgICAgICBpZiAoaW5kZXggPCBpbnRlcnZhbC5kYXRhLmxlbmd0aCkge1xyXG4vLyAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gaW50ZXJ2YWwuZGF0YVtpbmRleF07XHJcblxyXG4vLyAgICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzIHNlcGFyYXRlbHlcclxuLy8gICAgICAgICAgICAgICAgIGlmICh2YWwgPiAwICYmIHZhbCA+IHBvc01heCkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHBvc01heCA9IHZhbDtcclxuLy8gICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsIDwgbmVnTWF4KSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgbmVnTWF4ID0gdmFsO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICAgIHZhbHMucHVzaChbbmVnTWF4LCBwb3NNYXhdKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiB2YWxzO1xyXG4vLyB9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3RyYXRlZ2llcy9jYWxjdWxhdGUvcGVhay5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!*****************************************!*\
  !*** ./src/strategies/calculate/rms.js ***!
  \*****************************************/
/*! exports provided: calculateRms */
/*! exports used: calculateRms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = calculateRms;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_interval__ = __webpack_require__(/*! ../../models/interval */ 0);\n\r\nconst savedValues = [];\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param {number} sampleRatio \r\n * @param {number} samplesPerPixel \r\n * @param {number} width \r\n * @param {number} height\r\n * @param {Interval[]} segments \r\n * @param {number} scrollPosition \r\n * @param {number} sampleRate\r\n * @param {CanvasRenderingContext2D} ctx \r\n * @param {CanvasRenderingContext2D} offScreenCtx \r\n * @returns \r\n */\r\nfunction calculateRms(sampleRatio, samplesPerPixel, width, height, segments, scrollPosition, sampleRate, ctx, offScreenCtx) {\r\n    const scale = height / 2;\r\n    const sampleSize = Math.max(1, samplesPerPixel / sampleRatio);\r\n    //const sampleSize = Math.max(1, Math.log2(samplesPerPixel));\r\n    const start = scrollPosition * samplesPerPixel;\r\n    const startSecond = start / sampleRate;\r\n\r\n    const vals = [];\r\n\r\n    offScreenCtx.beginPath();\r\n    // For each pixel we display\r\n    for (let i = 0; i < width; i++) {\r\n        let posSum = 0;\r\n        let negSum = 0;\r\n\r\n        const currentSecond = startSecond + ((i * samplesPerPixel) / sampleRate);\r\n        let interval;\r\n        for(let i = 0; i < segments.length; i++) {\r\n            const s = segments[i];\r\n            if(s.start <= currentSecond && s.end >= currentSecond) {\r\n                interval = s;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(interval == null) {\r\n            vals.push([posSum, negSum]);\r\n            continue;\r\n        }\r\n\r\n        const offsetStart = interval.start - interval.originalStart;\r\n        const secondsIntoInterval = currentSecond - interval.start;\r\n        const startSample = Math.floor(((secondsIntoInterval + offsetStart) * sampleRate));\r\n\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        for (let j = 0; j < samplesPerPixel; j += sampleSize) {\r\n            const index = j + startSample;\r\n            if (index < interval.data.length) {\r\n                const val = interval.data[index];\r\n\r\n                // Keep track of positive and negative values separately\r\n                if (val > 0) {\r\n                    posSum += val * val;\r\n                } else {\r\n                    negSum += val * val;\r\n                }\r\n            }\r\n        }\r\n\r\n        const samples = Math.round(samplesPerPixel / sampleSize);\r\n        const minHeight = -Math.sqrt(negSum / samples * 2) * scale + scale;\r\n        const maxHeight = Math.sqrt(posSum / samples * 2) * scale + scale;\r\n        const height = maxHeight - minHeight;\r\n\r\n        offScreenCtx.moveTo(i, minHeight);\r\n        offScreenCtx.lineTo(i, maxHeight)\r\n    }\r\n    offScreenCtx.closePath();\r\n    offScreenCtx.stroke();\r\n\r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.drawImage(offScreenCtx.canvas, 0, 0);\r\n    offScreenCtx.clearRect(0, 0, width, height);\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHJhdGVnaWVzL2NhbGN1bGF0ZS9ybXMuanM/OGI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcnZhbCB9IGZyb20gJy4uLy4uL21vZGVscy9pbnRlcnZhbCc7XHJcbmNvbnN0IHNhdmVkVmFsdWVzID0gW107XHJcblxyXG4vKipcclxuICogXHJcbiAqIFxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRpbyBcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXNQZXJQaXhlbCBcclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAqIEBwYXJhbSB7SW50ZXJ2YWxbXX0gc2VnbWVudHMgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxQb3NpdGlvbiBcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVJhdGVcclxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBcclxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IG9mZlNjcmVlbkN0eCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUm1zKHNhbXBsZVJhdGlvLCBzYW1wbGVzUGVyUGl4ZWwsIHdpZHRoLCBoZWlnaHQsIHNlZ21lbnRzLCBzY3JvbGxQb3NpdGlvbiwgc2FtcGxlUmF0ZSwgY3R4LCBvZmZTY3JlZW5DdHgpIHtcclxuICAgIGNvbnN0IHNjYWxlID0gaGVpZ2h0IC8gMjtcclxuICAgIGNvbnN0IHNhbXBsZVNpemUgPSBNYXRoLm1heCgxLCBzYW1wbGVzUGVyUGl4ZWwgLyBzYW1wbGVSYXRpbyk7XHJcbiAgICAvL2NvbnN0IHNhbXBsZVNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmxvZzIoc2FtcGxlc1BlclBpeGVsKSk7XHJcbiAgICBjb25zdCBzdGFydCA9IHNjcm9sbFBvc2l0aW9uICogc2FtcGxlc1BlclBpeGVsO1xyXG4gICAgY29uc3Qgc3RhcnRTZWNvbmQgPSBzdGFydCAvIHNhbXBsZVJhdGU7XHJcblxyXG4gICAgY29uc3QgdmFscyA9IFtdO1xyXG5cclxuICAgIG9mZlNjcmVlbkN0eC5iZWdpblBhdGgoKTtcclxuICAgIC8vIEZvciBlYWNoIHBpeGVsIHdlIGRpc3BsYXlcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgIGxldCBwb3NTdW0gPSAwO1xyXG4gICAgICAgIGxldCBuZWdTdW0gPSAwO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50U2Vjb25kID0gc3RhcnRTZWNvbmQgKyAoKGkgKiBzYW1wbGVzUGVyUGl4ZWwpIC8gc2FtcGxlUmF0ZSk7XHJcbiAgICAgICAgbGV0IGludGVydmFsO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmKHMuc3RhcnQgPD0gY3VycmVudFNlY29uZCAmJiBzLmVuZCA+PSBjdXJyZW50U2Vjb25kKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IHM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoaW50ZXJ2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWxzLnB1c2goW3Bvc1N1bSwgbmVnU3VtXSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSBpbnRlcnZhbC5zdGFydCAtIGludGVydmFsLm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kc0ludG9JbnRlcnZhbCA9IGN1cnJlbnRTZWNvbmQgLSBpbnRlcnZhbC5zdGFydDtcclxuICAgICAgICBjb25zdCBzdGFydFNhbXBsZSA9IE1hdGguZmxvb3IoKChzZWNvbmRzSW50b0ludGVydmFsICsgb2Zmc2V0U3RhcnQpICogc2FtcGxlUmF0ZSkpO1xyXG5cclxuICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRoZSBkYXRhLXBvaW50cyByZWxldmFudCB0byB0aGUgcGl4ZWxcclxuICAgICAgICAvLyBEb24ndCBjeWNsZSB0aHJvdWdoIG1vcmUgdGhhbiBzYW1wbGVTaXplIGZyYW1lcyBwZXIgcGl4ZWwuXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzYW1wbGVzUGVyUGl4ZWw7IGogKz0gc2FtcGxlU2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGogKyBzdGFydFNhbXBsZTtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgaW50ZXJ2YWwuZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGludGVydmFsLmRhdGFbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBzZXBhcmF0ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc1N1bSArPSB2YWwgKiB2YWw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5lZ1N1bSArPSB2YWwgKiB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSBNYXRoLnJvdW5kKHNhbXBsZXNQZXJQaXhlbCAvIHNhbXBsZVNpemUpO1xyXG4gICAgICAgIGNvbnN0IG1pbkhlaWdodCA9IC1NYXRoLnNxcnQobmVnU3VtIC8gc2FtcGxlcyAqIDIpICogc2NhbGUgKyBzY2FsZTtcclxuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLnNxcnQocG9zU3VtIC8gc2FtcGxlcyAqIDIpICogc2NhbGUgKyBzY2FsZTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXhIZWlnaHQgLSBtaW5IZWlnaHQ7XHJcblxyXG4gICAgICAgIG9mZlNjcmVlbkN0eC5tb3ZlVG8oaSwgbWluSGVpZ2h0KTtcclxuICAgICAgICBvZmZTY3JlZW5DdHgubGluZVRvKGksIG1heEhlaWdodClcclxuICAgIH1cclxuICAgIG9mZlNjcmVlbkN0eC5jbG9zZVBhdGgoKTtcclxuICAgIG9mZlNjcmVlbkN0eC5zdHJva2UoKTtcclxuXHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShvZmZTY3JlZW5DdHguY2FudmFzLCAwLCAwKTtcclxuICAgIG9mZlNjcmVlbkN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdHJhdGVnaWVzL2NhbGN1bGF0ZS9ybXMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!**********************************************!*\
  !*** ./src/strategies/render/double-loop.js ***!
  \**********************************************/
/*! exports provided: drawDoubleLoop */
/*! exports used: drawDoubleLoop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = drawDoubleLoop;\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param {number[][]} waveform Sampled data for each pixel, max at 0, min at 1 \r\n * @param {number} height \r\n * @param {number} width \r\n * @param {CanvasRenderingContext2D} ctx \r\n * @param {CanvasRenderingContext2D} offScreenCtx \r\n * @param {string} drawStyle \r\n */\r\nfunction drawDoubleLoop(waveform, height, width, ctx, offScreenCtx, drawStyle) {\r\n    const scale = height / 2;\r\n    offScreenCtx.clearRect(0, 0, width, height);\r\n    offScreenCtx.beginPath();\r\n\r\n    for (let i = 0; i < waveform.length; i++) {\r\n        const minHeight = (waveform[i][0] * scale) + scale;\r\n        const maxHeight = (waveform[i][1] * scale) + scale;\r\n        const height = maxHeight - minHeight;\r\n        offScreenCtx.rect(i, minHeight, 1, height);\r\n    }\r\n    offScreenCtx.closePath();\r\n    offScreenCtx.fill();\r\n    \r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.drawImage(offScreenCtx.canvas, 0, 0);\r\n    \r\n    // ctx.moveTo(0, scale);\r\n    // for (let i = 0; i < waveform.length; i++) {\r\n    //     ctx.lineTo(i, (waveform[i][0] * scale) + scale);\r\n    // }\r\n    // ctx.lineTo(waveform.length - 1, scale);\r\n\r\n    // ctx.moveTo(0, scale);\r\n    // for (let i = 0; i < waveform.length; i++) {\r\n    //     ctx.lineTo(i, (waveform[i][1] * scale) + scale);\r\n    // }\r\n    // ctx.lineTo(waveform.length - 1, scale);\r\n\r\n    // ctx.closePath();\r\n    // switch (drawStyle) { \r\n    //     case 'stroke':\r\n    //         ctx.stroke();\r\n    //         break;\r\n    //     default:\r\n    //         ctx.fill();\r\n    // }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHJhdGVnaWVzL3JlbmRlci9kb3VibGUtbG9vcC5qcz9jYWExIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKipcclxuICogXHJcbiAqIFxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7bnVtYmVyW11bXX0gd2F2ZWZvcm0gU2FtcGxlZCBkYXRhIGZvciBlYWNoIHBpeGVsLCBtYXggYXQgMCwgbWluIGF0IDEgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBcclxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBcclxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IG9mZlNjcmVlbkN0eCBcclxuICogQHBhcmFtIHtzdHJpbmd9IGRyYXdTdHlsZSBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkcmF3RG91YmxlTG9vcCh3YXZlZm9ybSwgaGVpZ2h0LCB3aWR0aCwgY3R4LCBvZmZTY3JlZW5DdHgsIGRyYXdTdHlsZSkge1xyXG4gICAgY29uc3Qgc2NhbGUgPSBoZWlnaHQgLyAyO1xyXG4gICAgb2ZmU2NyZWVuQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIG9mZlNjcmVlbkN0eC5iZWdpblBhdGgoKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdhdmVmb3JtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbWluSGVpZ2h0ID0gKHdhdmVmb3JtW2ldWzBdICogc2NhbGUpICsgc2NhbGU7XHJcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gKHdhdmVmb3JtW2ldWzFdICogc2NhbGUpICsgc2NhbGU7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF4SGVpZ2h0IC0gbWluSGVpZ2h0O1xyXG4gICAgICAgIG9mZlNjcmVlbkN0eC5yZWN0KGksIG1pbkhlaWdodCwgMSwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIG9mZlNjcmVlbkN0eC5jbG9zZVBhdGgoKTtcclxuICAgIG9mZlNjcmVlbkN0eC5maWxsKCk7XHJcbiAgICBcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICBjdHguZHJhd0ltYWdlKG9mZlNjcmVlbkN0eC5jYW52YXMsIDAsIDApO1xyXG4gICAgXHJcbiAgICAvLyBjdHgubW92ZVRvKDAsIHNjYWxlKTtcclxuICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgd2F2ZWZvcm0ubGVuZ3RoOyBpKyspIHtcclxuICAgIC8vICAgICBjdHgubGluZVRvKGksICh3YXZlZm9ybVtpXVswXSAqIHNjYWxlKSArIHNjYWxlKTtcclxuICAgIC8vIH1cclxuICAgIC8vIGN0eC5saW5lVG8od2F2ZWZvcm0ubGVuZ3RoIC0gMSwgc2NhbGUpO1xyXG5cclxuICAgIC8vIGN0eC5tb3ZlVG8oMCwgc2NhbGUpO1xyXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB3YXZlZm9ybS5sZW5ndGg7IGkrKykge1xyXG4gICAgLy8gICAgIGN0eC5saW5lVG8oaSwgKHdhdmVmb3JtW2ldWzFdICogc2NhbGUpICsgc2NhbGUpO1xyXG4gICAgLy8gfVxyXG4gICAgLy8gY3R4LmxpbmVUbyh3YXZlZm9ybS5sZW5ndGggLSAxLCBzY2FsZSk7XHJcblxyXG4gICAgLy8gY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgLy8gc3dpdGNoIChkcmF3U3R5bGUpIHsgXHJcbiAgICAvLyAgICAgY2FzZSAnc3Ryb2tlJzpcclxuICAgIC8vICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgLy8gICAgICAgICBicmVhaztcclxuICAgIC8vICAgICBkZWZhdWx0OlxyXG4gICAgLy8gICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgLy8gfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3RyYXRlZ2llcy9yZW5kZXIvZG91YmxlLWxvb3AuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!********************************!*\
  !*** ./src/methods/flatten.js ***!
  \********************************/
/*! exports provided: flattenSegments */
/*! exports used: flattenSegments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = flattenSegments;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_segment__ = __webpack_require__(/*! ../models/segment */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_interval__ = __webpack_require__(/*! ../models/interval */ 0);\n\r\n\r\n\r\n/**\r\n *\r\n * @param {number} a\r\n * @param {number} b\r\n */\r\nconst cmp = (a, b) => {\r\n  if (a > b) return +1;\r\n  if (a < b) return -1;\r\n  return 0;\r\n};\r\n\r\nvar groupBy = function(xs, key) {\r\n  return xs.reduce(function(rv, x) {\r\n    (rv[x[key]] = rv[x[key]] || []).push(x);\r\n    return rv;\r\n  }, {});\r\n};\r\n\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param {Segment[]} segments\r\n * @returns {Interval[]}\r\n */\r\nfunction flattenSegments(segments) {\r\n  let ind = 0;\r\n  let lastIndex = -1;\r\n\r\n  segments.sort((a, b) => cmp(a.index, b.index) || cmp(a.start, b.start)).forEach(el => {\r\n    if (el.index != lastIndex) {\r\n      el.index = ind;\r\n      lastIndex = ind;\r\n      ind++;\r\n    } else {\r\n      el.index = ind;\r\n    }\r\n  });\r\n\r\n  var intervals = segments\r\n    .map(s => {\r\n      return {\r\n        id: s.id,\r\n        start: s.start + s.offsetStart,\r\n        end: s.start + s.duration - s.offsetEnd,\r\n        index: s.index,\r\n        originalStart: s.start,\r\n        data: s.data\r\n      };\r\n    })\r\n    .sort((a, b) => {\r\n      return cmp(a.index, b.index) || cmp(a.start, b.start);\r\n    });\r\n\r\n  var grouped = groupBy(intervals, \"index\");\r\n  var indexes = Object.keys(grouped);\r\n\r\n  if (indexes.length === 1) {\r\n    return intervals;\r\n  }\r\n\r\n  var weak;\r\n  for (var index in Object.keys(grouped)) {\r\n    if (weak == null) {\r\n      weak = grouped[index];\r\n    } else {\r\n      weak = combine(grouped[index], weak);\r\n    }\r\n  }\r\n\r\n  var final = merge(weak);\r\n  return final;\r\n}\r\n\r\n/**\r\n *\r\n *\r\n * @param {[]} S\r\n * @param {[]} W\r\n */\r\nfunction combine(S, W) {\r\n  var s = 0;\r\n  var w = 0;\r\n  var common = [];\r\n\r\n  while (s < S.length || w < W.length) {\r\n    // Only low priority left so push it on the stack\r\n    if (s === S.length) {\r\n      common.push(Object.assign({}, W[w]));\r\n      w++;\r\n      // Only high priority left so push it on the stack\r\n    } else if (w === W.length) {\r\n      common.push(Object.assign(S[s]));\r\n      s++;\r\n      // if high priority starts first\r\n    } else if (S[s].start <= W[w].start) {\r\n      W[w].start = Math.max(W[w].start, S[s].end);\r\n      if (W[w].start >= W[w].end) {\r\n        w++;\r\n      }\r\n      common.push(Object.assign({}, S[s]));\r\n      s++;\r\n    } else if (S[s].start >= W[w].start) {\r\n      // end point of weak interval before the start of the strong\r\n      if (W[w].end <= S[s].start) {\r\n        common.push(Object.assign({}, W[w]));\r\n        w++;\r\n      } else if (S[s].start <= W[w].end && W[w].end <= S[s].end) {\r\n        W[w].end = S[s].start;\r\n        common.push(Object.assign({}, W[w]));\r\n        w++;\r\n      } else if (W[w].end >= S[s].end) {\r\n        common.push(\r\n          Object.assign({}, W[w], {\r\n            end: S[s].start\r\n          })\r\n        );\r\n        W[w].start = S[s].end;\r\n      }\r\n    }\r\n  }\r\n\r\n  return common;\r\n}\r\n\r\n/**\r\n * \r\n * \r\n * @param {Interval[]} intervals \r\n * @returns {Interval[]}\r\n */\r\nfunction merge(intervals) {\r\n  if (intervals == null || intervals.length <= 1) return intervals;\r\n\r\n  var result = [];\r\n  var prev = intervals[0];\r\n  for (var i = 1; i < intervals.length; i++) {\r\n    var curr = intervals[i];\r\n\r\n    if (prev.end >= curr.start && prev.index === curr.index) {\r\n      // merged case\r\n      var merged = Object.assign({}, prev, { end: Math.max(prev.end, curr.end)});\r\n      prev = merged;\r\n    } else {\r\n      result.push(prev);\r\n      prev = curr;\r\n    }\r\n  }\r\n\r\n  result.push(prev);\r\n  return result;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tZXRob2RzL2ZsYXR0ZW4uanM/OGQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZWdtZW50IH0gZnJvbSBcIi4uL21vZGVscy9zZWdtZW50XCI7XHJcbmltcG9ydCB7IEludGVydmFsIH0gZnJvbSBcIi4uL21vZGVscy9pbnRlcnZhbFwiO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXHJcbiAqL1xyXG5jb25zdCBjbXAgPSAoYSwgYikgPT4ge1xyXG4gIGlmIChhID4gYikgcmV0dXJuICsxO1xyXG4gIGlmIChhIDwgYikgcmV0dXJuIC0xO1xyXG4gIHJldHVybiAwO1xyXG59O1xyXG5cclxudmFyIGdyb3VwQnkgPSBmdW5jdGlvbih4cywga2V5KSB7XHJcbiAgcmV0dXJuIHhzLnJlZHVjZShmdW5jdGlvbihydiwgeCkge1xyXG4gICAgKHJ2W3hba2V5XV0gPSBydlt4W2tleV1dIHx8IFtdKS5wdXNoKHgpO1xyXG4gICAgcmV0dXJuIHJ2O1xyXG4gIH0sIHt9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYWxnb3JpdGhtIGZpcnN0IGNhbGN1bGF0ZXMgcmVhbCBzdGFydCBhbmQgZW5kIHRpbWVzIG9mIGVhY2ggc2VnbWVudCxcclxuICogc29ydHMgdGhlbSBieSBwcmlvcml0eSwgdGhlbiBzdGFydCB0aW1lLlxyXG4gKlxyXG4gKiBGaW5hbGx5IGl0IG1lcmdlcyB0aGUgc2VnbWVudHMgYnkgaW5kZXggc28gdGhlcmUgYXJlIG5vIG92ZXJsYXBwaW5nXHJcbiAqIHNlZ21lbnRzIGFuZCB0aG9zZSB3aXRoIGhpZ2hlc3QgaW5kZXggYXJlIG9uIHRvcC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcclxuICogQHJldHVybnMge0ludGVydmFsW119XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblNlZ21lbnRzKHNlZ21lbnRzKSB7XHJcbiAgbGV0IGluZCA9IDA7XHJcbiAgbGV0IGxhc3RJbmRleCA9IC0xO1xyXG5cclxuICBzZWdtZW50cy5zb3J0KChhLCBiKSA9PiBjbXAoYS5pbmRleCwgYi5pbmRleCkgfHwgY21wKGEuc3RhcnQsIGIuc3RhcnQpKS5mb3JFYWNoKGVsID0+IHtcclxuICAgIGlmIChlbC5pbmRleCAhPSBsYXN0SW5kZXgpIHtcclxuICAgICAgZWwuaW5kZXggPSBpbmQ7XHJcbiAgICAgIGxhc3RJbmRleCA9IGluZDtcclxuICAgICAgaW5kKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbC5pbmRleCA9IGluZDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgdmFyIGludGVydmFscyA9IHNlZ21lbnRzXHJcbiAgICAubWFwKHMgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBzLmlkLFxyXG4gICAgICAgIHN0YXJ0OiBzLnN0YXJ0ICsgcy5vZmZzZXRTdGFydCxcclxuICAgICAgICBlbmQ6IHMuc3RhcnQgKyBzLmR1cmF0aW9uIC0gcy5vZmZzZXRFbmQsXHJcbiAgICAgICAgaW5kZXg6IHMuaW5kZXgsXHJcbiAgICAgICAgb3JpZ2luYWxTdGFydDogcy5zdGFydCxcclxuICAgICAgICBkYXRhOiBzLmRhdGFcclxuICAgICAgfTtcclxuICAgIH0pXHJcbiAgICAuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICByZXR1cm4gY21wKGEuaW5kZXgsIGIuaW5kZXgpIHx8IGNtcChhLnN0YXJ0LCBiLnN0YXJ0KTtcclxuICAgIH0pO1xyXG5cclxuICB2YXIgZ3JvdXBlZCA9IGdyb3VwQnkoaW50ZXJ2YWxzLCBcImluZGV4XCIpO1xyXG4gIHZhciBpbmRleGVzID0gT2JqZWN0LmtleXMoZ3JvdXBlZCk7XHJcblxyXG4gIGlmIChpbmRleGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgcmV0dXJuIGludGVydmFscztcclxuICB9XHJcblxyXG4gIHZhciB3ZWFrO1xyXG4gIGZvciAodmFyIGluZGV4IGluIE9iamVjdC5rZXlzKGdyb3VwZWQpKSB7XHJcbiAgICBpZiAod2VhayA9PSBudWxsKSB7XHJcbiAgICAgIHdlYWsgPSBncm91cGVkW2luZGV4XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdlYWsgPSBjb21iaW5lKGdyb3VwZWRbaW5kZXhdLCB3ZWFrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBmaW5hbCA9IG1lcmdlKHdlYWspO1xyXG4gIHJldHVybiBmaW5hbDtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSB7W119IFNcclxuICogQHBhcmFtIHtbXX0gV1xyXG4gKi9cclxuZnVuY3Rpb24gY29tYmluZShTLCBXKSB7XHJcbiAgdmFyIHMgPSAwO1xyXG4gIHZhciB3ID0gMDtcclxuICB2YXIgY29tbW9uID0gW107XHJcblxyXG4gIHdoaWxlIChzIDwgUy5sZW5ndGggfHwgdyA8IFcubGVuZ3RoKSB7XHJcbiAgICAvLyBPbmx5IGxvdyBwcmlvcml0eSBsZWZ0IHNvIHB1c2ggaXQgb24gdGhlIHN0YWNrXHJcbiAgICBpZiAocyA9PT0gUy5sZW5ndGgpIHtcclxuICAgICAgY29tbW9uLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgV1t3XSkpO1xyXG4gICAgICB3Kys7XHJcbiAgICAgIC8vIE9ubHkgaGlnaCBwcmlvcml0eSBsZWZ0IHNvIHB1c2ggaXQgb24gdGhlIHN0YWNrXHJcbiAgICB9IGVsc2UgaWYgKHcgPT09IFcubGVuZ3RoKSB7XHJcbiAgICAgIGNvbW1vbi5wdXNoKE9iamVjdC5hc3NpZ24oU1tzXSkpO1xyXG4gICAgICBzKys7XHJcbiAgICAgIC8vIGlmIGhpZ2ggcHJpb3JpdHkgc3RhcnRzIGZpcnN0XHJcbiAgICB9IGVsc2UgaWYgKFNbc10uc3RhcnQgPD0gV1t3XS5zdGFydCkge1xyXG4gICAgICBXW3ddLnN0YXJ0ID0gTWF0aC5tYXgoV1t3XS5zdGFydCwgU1tzXS5lbmQpO1xyXG4gICAgICBpZiAoV1t3XS5zdGFydCA+PSBXW3ddLmVuZCkge1xyXG4gICAgICAgIHcrKztcclxuICAgICAgfVxyXG4gICAgICBjb21tb24ucHVzaChPYmplY3QuYXNzaWduKHt9LCBTW3NdKSk7XHJcbiAgICAgIHMrKztcclxuICAgIH0gZWxzZSBpZiAoU1tzXS5zdGFydCA+PSBXW3ddLnN0YXJ0KSB7XHJcbiAgICAgIC8vIGVuZCBwb2ludCBvZiB3ZWFrIGludGVydmFsIGJlZm9yZSB0aGUgc3RhcnQgb2YgdGhlIHN0cm9uZ1xyXG4gICAgICBpZiAoV1t3XS5lbmQgPD0gU1tzXS5zdGFydCkge1xyXG4gICAgICAgIGNvbW1vbi5wdXNoKE9iamVjdC5hc3NpZ24oe30sIFdbd10pKTtcclxuICAgICAgICB3Kys7XHJcbiAgICAgIH0gZWxzZSBpZiAoU1tzXS5zdGFydCA8PSBXW3ddLmVuZCAmJiBXW3ddLmVuZCA8PSBTW3NdLmVuZCkge1xyXG4gICAgICAgIFdbd10uZW5kID0gU1tzXS5zdGFydDtcclxuICAgICAgICBjb21tb24ucHVzaChPYmplY3QuYXNzaWduKHt9LCBXW3ddKSk7XHJcbiAgICAgICAgdysrO1xyXG4gICAgICB9IGVsc2UgaWYgKFdbd10uZW5kID49IFNbc10uZW5kKSB7XHJcbiAgICAgICAgY29tbW9uLnB1c2goXHJcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBXW3ddLCB7XHJcbiAgICAgICAgICAgIGVuZDogU1tzXS5zdGFydFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgICAgIFdbd10uc3RhcnQgPSBTW3NdLmVuZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbW1vbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBcclxuICogQHBhcmFtIHtJbnRlcnZhbFtdfSBpbnRlcnZhbHMgXHJcbiAqIEByZXR1cm5zIHtJbnRlcnZhbFtdfVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2UoaW50ZXJ2YWxzKSB7XHJcbiAgaWYgKGludGVydmFscyA9PSBudWxsIHx8IGludGVydmFscy5sZW5ndGggPD0gMSkgcmV0dXJuIGludGVydmFscztcclxuXHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIHZhciBwcmV2ID0gaW50ZXJ2YWxzWzBdO1xyXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgY3VyciA9IGludGVydmFsc1tpXTtcclxuXHJcbiAgICBpZiAocHJldi5lbmQgPj0gY3Vyci5zdGFydCAmJiBwcmV2LmluZGV4ID09PSBjdXJyLmluZGV4KSB7XHJcbiAgICAgIC8vIG1lcmdlZCBjYXNlXHJcbiAgICAgIHZhciBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCBwcmV2LCB7IGVuZDogTWF0aC5tYXgocHJldi5lbmQsIGN1cnIuZW5kKX0pO1xyXG4gICAgICBwcmV2ID0gbWVyZ2VkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0LnB1c2gocHJldik7XHJcbiAgICAgIHByZXYgPSBjdXJyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVzdWx0LnB1c2gocHJldik7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tZXRob2RzL2ZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!****************************************************!*\
  !*** ./node_modules/hamsters.js/build/hamsters.js ***!
  \****************************************************/
/*! dynamic exports provided */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*\n* Title: Hamsters.js\n* Description: Javascript library to add multi-threading support to javascript by exploiting concurrent web workers\n* Author: Austin K. Smith\n* Contact: austin@asmithdev.com\n* Copyright: 2015 Austin K. Smith - austin@asmithdev.com\n* License: Artistic License 2.0\n*/\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar hamsters = {\n  version: '4.2.1',\n  debug: false,\n  cache: false,\n  persistence: true,\n  maxThreads: 4,\n  atomics: false,\n  habitat: {\n    legacy: false,\n    node: false,\n    shell: false,\n    worker: false,\n    browser: false,\n    ie10: false,\n    atomics: false,\n    transferrable: true\n  },\n  tools: {},\n  pool: {\n    errors: [],\n    tasks: [],\n    threads: [],\n    running: [],\n    pending: []\n  },\n  uri: null\n};\n\nhamsters.init = function (startOptions) {\n  setupHamstersEnvironment(startOptions, function () {\n    if (hamsters.habitat.legacy) {\n      hamsters.pool.newWheel = legacyHamsterWheel;\n    } else {\n      hamsters.pool.newWheel = hamsterWheel;\n      spawnHamsters();\n    }\n    chewGarbage(startOptions);\n  });\n  hamsters.run = runHamster;\n  hamsters.tools.randomArray = randomArray;\n  hamsters.tools.loop = loop;\n  hamsters.tools.parseJson = parseJsonOnThread;\n  hamsters.tools.stringifyJson = stringifyJsonOnThread;\n};\n\nfunction isIE(version) {\n  return new RegExp('msie' + (!isNaN(version) ? '\\\\s' + version : ''), 'i').test(navigator.userAgent);\n}\n\nfunction setupBrowserSupport() {\n  if (!Worker || ['Kindle/3.0', 'Mobile/8F190', 'IEMobile'].indexOf(navigator.userAgent) !== -1) {\n    hamsters.habitat.legacy = true;\n  }\n  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1) {\n    hamsters.maxThreads = hamsters.maxThreads > 20 ? 20 : hamsters.maxThreads;\n  }\n  if (isIE(10)) {\n    try {\n      var testThread = new Worker('src/common/wheel.min.js');\n      testThread.terminate();\n      hamsters.habitat.ie10 = true;\n    } catch (e) {\n      hamsters.habitat.legacy = true;\n    }\n  }\n}\n\nfunction setupWorkerSupport() {\n  try {\n    var workerBlob = generateWorkerBlob();\n    var SharedHamster = new SharedWorker(workerBlob, 'SharedHamsterWheel');\n    hamsters.uri = workerBlob;\n  } catch (e) {\n    hamsters.habitat.legacy = true;\n  }\n}\n\nfunction processStartOptions(startOptions) {\n  for (var key in startOptions) {\n    if (startOptions.hasOwnProperty(key)) {\n      hamsters[key] = startOptions[key];\n    }\n  }\n}\n\nfunction setupHamstersEnvironment(startOptions, onSuccess) {\n  hamsters.habitat.browser = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === \"object\";\n  hamsters.habitat.worker = typeof importScripts === \"function\";\n  hamsters.habitat.node = (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === \"object\" && \"function\" === \"function\" && !hamsters.habitat.browser && !hamsters.habitat.worker && !hamsters.habitat.reactNative;\n  hamsters.habitat.reactNative = !hamsters.habitat.node && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object';\n  hamsters.habitat.shell = !hamsters.habitat.browser && !hamsters.habitat.node && !hamsters.habitat.worker && !hamsters.habitat.reactNative;\n  if (typeof navigator !== 'undefined' && typeof navigator.hardwareConcurrency !== 'undefined') {\n    hamsters.maxThreads = navigator.hardwareConcurrency;\n  }\n  if (typeof startOptions !== 'undefined') {\n    processStartOptions(startOptions);\n  }\n  if (hamsters.habitat.browser && !hamsters.habitat.reactNative) {\n    setupBrowserSupport();\n  }\n  if (hamsters.habitat.worker) {\n    setupWorkerSupport();\n  }\n  if (hamsters.habitat.node || hamsters.habitat.reactNative) {\n    if (typeof hamsters.Worker !== 'undefined') {\n      global.Worker = hamsters.Worker;\n    }\n  }\n  if (hamsters.habitat.shell || typeof Worker === 'undefined') {\n    hamsters.habitat.legacy = true;\n  }\n  if (typeof Uint8Array === 'undefined') {\n    hamsters.habitat.transferrable = false;\n  }\n  if (typeof SharedArrayBuffer !== 'undefined') {\n    hamsters.habitat.atomics = true;\n  }\n  onSuccess();\n}\n\nfunction generateWorkerBlob() {\n  return URL.createObjectURL(createBlob('(' + String(giveHamsterWork()) + ')();'));\n}\n\nfunction spawnHamsters() {\n  if (hamsters.habitat.browser) {\n    hamsters.uri = generateWorkerBlob();\n  }\n  if (hamsters.persistence) {\n    var i = hamsters.maxThreads;\n    for (i; i > 0; i--) {\n      hamsters.pool.threads.push(spawnHamster());\n    }\n  }\n}\n\nfunction spawnHamster() {\n  if (hamsters.habitat.ie10) {\n    return new Worker('src/common/wheel.min.js');\n  } else if (hamsters.habitat.worker) {\n    return new SharedWorker(hamsters.uri, 'SharedHamsterWheel');\n  } else if (hamsters.habitat.node) {\n    return new Worker(giveHamsterWork());\n  } else {\n    return new Worker(hamsters.uri);\n  }\n}\n\nfunction giveHamsterWork() {\n  if (hamsters.habitat.worker) {\n    return workerWorker;\n  }\n  return worker;\n}\n\nfunction createBlob(textContent) {\n  if (!Blob) {\n    var BlobMaker = BlobBuilder || WebKitBlobBuilder || MozBlobBuilder || MSBlobBuilder;\n    var blob = new BlobMaker();\n    blob.append([textContent], {\n      type: 'application/javascript'\n    });\n    return blob.getBlob();\n  }\n  return new Blob([textContent], {\n    type: 'application/javascript'\n  });\n}\n\nfunction workerWorker() {\n  addEventListener(\"connect\", function (e) {\n    var port = e.ports[0];\n    port.start();\n    port.addEventListener(\"message\", function (e) {\n      self.params = e.data;\n      self.rtn = {\n        data: [],\n        dataType: params.dataType\n      };\n      var fn = eval(\"(\" + params.fn + \")\");\n      if (fn) {\n        fn();\n      }\n      port.postMessage({\n        results: rtn\n      });\n    }, false);\n  }, false);\n}\n\nfunction worker() {\n  function processDataType(dataType, buffer) {\n    var types = {\n      'uint32': Uint32Array,\n      'uint16': Uint16Array,\n      'uint8': Uint8Array,\n      'uint8clamped': Uint8ClampedArray,\n      'int32': Int32Array,\n      'int16': Int16Array,\n      'int8': Int8Array,\n      'float32': Float32Array,\n      'float64': Float64Array\n    };\n    if (!types[dataType]) {\n      return buffer;\n    }\n    return new types[dataType](buffer);\n  }\n\n  onmessage = function onmessage(e) {\n    self.params = e.data;\n    self.rtn = {\n      data: [],\n      dataType: params.dataType\n    };\n    var fn = new Function(params.fn);\n    if (fn) {\n      fn();\n    }\n    if (params.dataType) {\n      rtn.data = processDataType(params.dataType, rtn.data);\n      postMessage({\n        results: rtn\n      }, [rtn.data.buffer]);\n    } else {\n      postMessage({\n        results: rtn\n      });\n    }\n    //Garbage collection\n    self.params = undefined;\n    self.rtn = undefined;\n  };\n}\n\nfunction legacyHamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {\n  trackThread(task, hamsters.pool.running, thread_id);\n  if (memoize || hamsters.debug) {\n    trackInput(inputArray, thread_id, task, hamsterFood);\n  }\n  legacyProcessor(hamsterFood, inputArray, function (output) {\n    clean(task, thread_id);\n    task.output[thread_id] = output.data;\n    if (task.workers.length === 0 && task.count === task.threads) {\n      onSuccess(getOutput(task.output, aggregate, output.dataType));\n      hamsters.pool.tasks[task.id] = null;\n      if (hamsters.cache && memoize !== false) {\n        memoize(task.fn, task.input, output.data, output.dataType);\n      }\n    }\n  });\n  task.count += 1; //Thread finished\n}\n\nfunction hamsterWheel(inputArray, hamsterFood, aggregate, onSuccess, task, thread_id, hamster, memoize) {\n  if (hamsters.maxThreads === hamsters.pool.running.length) {\n    poolThread(inputArray, hamsterFood, thread_id, onSuccess, task, aggregate, memoize);\n    return;\n  }\n  if (memoize || hamsters.debug) {\n    trackInput(inputArray, thread_id, task, hamsterFood);\n  }\n  if (!hamster) {\n    if (hamsters.persistence) {\n      hamster = hamsters.pool.threads[hamsters.pool.running.length];\n    } else {\n      hamster = spawnHamster();\n    }\n  }\n  trainHamster(thread_id, aggregate, onSuccess, task, hamster, memoize);\n  trackThread(task, hamsters.pool.running, thread_id);\n  hamsterFood.array = inputArray;\n  feedHamster(hamster, hamsterFood);\n  task.count += 1; //Increment count, thread is running\n  if (hamsters.debug === 'verbose') {\n    console.info('Spawning Hamster #' + thread_id + ' @ ' + new Date().getTime());\n  }\n}\n\nfunction chewGarbage(startOptions) {\n  delete hamsters.init;\n  startOptions = null;\n}\n\nfunction splitArray(array, n) {\n  var i = 0;\n  var threadArrays = [];\n  var size = Math.ceil(array.length / n);\n  if (array.slice) {\n    while (i < array.length) {\n      threadArrays.push(array.slice(i, i += size));\n    }\n  } else {\n    while (i < array.length) {\n      threadArrays.push(array.subarray(i, i += size));\n    }\n  }\n  return threadArrays;\n}\n\nfunction loop(input, onSuccess) {\n  var params = {\n    run: prepareFunction(input.operator),\n    init: input.startIndex || 0,\n    limit: input.limit,\n    array: input.array,\n    incrementBy: input.incrementBy || 1,\n    dataType: input.dataType || null,\n    worker: hamsters.habitat.worker\n  };\n  runHamster(params, function () {\n    var operator = params.run;\n    if (typeof operator === \"string\") {\n      if (params.worker) {\n        operator = eval(\"(\" + operator + \")\");\n      } else {\n        operator = new Function(operator);\n      }\n    }\n    if (!params.limit) {\n      params.limit = params.array.length;\n    }\n    var i = params.init;\n    for (i; i < params.limit; i += params.incrementBy) {\n      rtn.data[i] = operator(params.array[i]);\n    }\n  }, function (rtn) {\n    onSuccess(rtn);\n  }, input.threads, 1, input.dataType);\n}\n\nfunction prepareFunction(functionBody) {\n  if (!hamsters.habitat.legacy) {\n    functionBody = String(functionBody);\n    if (!hamsters.habitat.worker) {\n      var startingIndex = functionBody.indexOf(\"{\") + 1;\n      var endingIndex = functionBody.length - 1;\n      return functionBody.substring(startingIndex, endingIndex);\n    }\n  }\n  return functionBody;\n}\n\nfunction parseJsonOnThread(string, onSuccess) {\n  runHamster({ input: string }, function () {\n    rtn.data = JSON.parse(params.input);\n  }, function (output) {\n    onSuccess(output[0]);\n  }, 1);\n}\n\nfunction stringifyJsonOnThread(json, onSuccess) {\n  runHamster({ input: json }, function () {\n    rtn.data = JSON.stringify(params.input);\n  }, function (output) {\n    onSuccess(output[0]);\n  }, 1);\n}\n\nfunction randomArray(count, onSuccess) {\n  var params = {\n    count: count\n  };\n  runHamster(params, function () {\n    while (params.count > 0) {\n      rtn.data[rtn.data.length] = Math.round(Math.random() * (100 - 1) + 1);\n      params.count -= 1;\n    }\n  }, function (result) {\n    onSuccess(result);\n  });\n}\n\nfunction aggregateThreadOutputs(input, dataType) {\n  if (!dataType || !hamsters.habitat.transferrable) {\n    return input.reduce(function (a, b) {\n      return a.concat(b);\n    });\n  }\n  var i = 0;\n  var len = input.length;\n  var bufferLength = 0;\n  for (i; i < len; i += 1) {\n    bufferLength += input[i].length;\n  }\n  var output = processDataType(dataType, bufferLength);\n  var offset = 0;\n  for (i = 0; i < len; i += 1) {\n    output.set(input[i], offset);\n    offset += input[i].length;\n  }\n  return output;\n}\n\nfunction checkCache(fn, input, dataType) {\n  var cachedResult = hamsters.cache[fn];\n  if (cachedResult) {\n    if (cachedResult[0] === input && cachedResult[2] === dataType) {\n      return cachedResult;\n    }\n  }\n}\n\nfunction memoize(fn, inputArray, output, dataType) {\n  hamsters.cache[fn] = [inputArray, output, dataType];\n}\n\nfunction sort(arr, order) {\n  switch (order) {\n    case 'desc':\n    case 'asc':\n      return Array.prototype.sort.call(arr, function (a, b) {\n        return order === 'asc' ? a - b : b - a;\n      });\n    case 'ascAlpha':\n      return arr.sort();\n    case 'descAlpha':\n      return arr.reverse();\n    default:\n      return arr;\n  }\n}\n\nfunction runHamster(params, fn, onSuccess, workers, aggregate, dataType, memoize, order) {\n  if (!params || !fn) {\n    return 'Error processing for loop, missing params or function';\n  }\n  workers = hamsters.habitat.legacy ? 1 : workers || 1;\n  var task = newTask(hamsters.pool.tasks.length, workers, order, dataType, fn, onSuccess);\n  if (dataType) {\n    dataType = dataType.toLowerCase();\n  }\n  if (hamsters.cache && memoize) {\n    var result = checkCache(fn, task.input, dataType);\n    if (result && onSuccess) {\n      setTimeout(function () {\n        hamsters.pool.tasks[taskid] = null; //Clean up our task, not needed any longer\n        onSuccess(result);\n      }, 4);\n      return;\n    }\n  }\n  work(task, params, fn, onSuccess, aggregate, dataType, memoize, order);\n}\n\nfunction work(task, params, fn, onSuccess, aggregate, dataType, memoize, order) {\n  var workArray = params.array;\n  if (workArray && task.threads !== 1) {\n    workArray = splitArray(workArray, task.threads); //Divide our array into equal array sizes\n  }\n  var food = {};\n  var key = void 0;\n  for (key in params) {\n    if (params.hasOwnProperty(key) && key !== 'array') {\n      food[key] = params[key];\n    }\n  }\n  food.fn = prepareFunction(fn);\n  food.dataType = dataType;\n  var i = 0;\n  while (i < task.threads) {\n    if (workArray && task.threads !== 1) {\n      hamsters.pool.newWheel(workArray[i], food, aggregate, onSuccess, task, task.count, null, memoize);\n    } else {\n      hamsters.pool.newWheel(workArray, food, aggregate, onSuccess, task, task.count, null, memoize);\n    }\n    i += 1;\n  }\n}\n\nfunction newTask(taskid, workers, order, dataType, fn, cb) {\n  hamsters.pool.tasks.push({\n    id: taskid,\n    workers: [],\n    count: 0,\n    threads: workers,\n    input: [],\n    dataType: dataType || null,\n    fn: fn,\n    output: [],\n    order: order || null,\n    onSuccess: cb\n  });\n  return hamsters.pool.tasks[taskid];\n}\n\nfunction assignOutput(task, inputArray) {\n  if (!task || !inputArray || !hamsters.habitat.atomics) {\n    return;\n  }\n  task.output = new SharedArrayBuffer(inputArray.length);\n}\n\nfunction trackInput(inputArray, thread_id, task, hamsterFood) {\n  task.input.push({\n    input: inputArray,\n    workerid: thread_id,\n    taskid: task.id,\n    params: hamsterFood,\n    start: new Date().getTime()\n  });\n}\n\nfunction trackThread(task, running, id) {\n  task.workers.push(id); //Keep track of threads scoped to current task\n  running.push(id); //Keep track of all currently running threads\n}\n\nfunction poolThread(inputArray, hamsterFood, thread_id, cb, task, agg, memoize) {\n  hamsters.pool.pending.push({\n    memoize: memoize,\n    input: inputArray,\n    params: hamsterFood,\n    workerid: thread_id,\n    onSuccess: cb,\n    task: task,\n    aggregate: agg\n  });\n}\n\nfunction legacyProcessor(params, inputArray, onSuccess) {\n  setTimeout(function () {\n    var rtn = {\n      success: true,\n      data: []\n    };\n    var params = params;\n    params.array = inputArray;\n    params.fn();\n    if (params.dataType && params.dataType != \"na\") {\n      rtn.data = processDataType(params.dataType, rtn.data);\n      rtn.dataType = params.dataType;\n    }\n    onSuccess(rtn);\n  }, 4); //4ms delay (HTML5 spec minimum), simulate threading\n}\n\nfunction getOutput(output, aggregate, dataType) {\n  if (aggregate && output.length <= 20) {\n    return aggregateThreadOutputs(output, dataType);\n  }\n  return output;\n}\n\nfunction processQueue(hamster, item) {\n  if (!item) {\n    return;\n  }\n  hamsters.pool.newWheel(item.input, item.params, item.aggregate, item.onSuccess, item.task, item.workerid, hamster, item.memoize); //Assign most recently finished thread to queue item\n}\n\nfunction clean(task, id) {\n  hamsters.pool.running.splice(hamsters.pool.running.indexOf(id), 1); //Remove thread from running pool\n  task.workers.splice(task.workers.indexOf(id), 1); //Remove thread from task running pool\n}\n\nfunction trainHamster(id, aggregate, onSuccess, task, hamster, memoize) {\n  function onmessage(e, results) {\n    clean(task, id);\n    results = e.data.results;\n    task.output[id] = results.data;\n    if (hamsters.debug === 'verbose') {\n      console.info('Hamster #' + id + ' finished ' + '@ ' + e.timeStamp);\n    }\n    if (task.workers.length === 0 && task.count === task.threads) {\n      if (task.order) {\n        onSuccess(sort(getOutput(task.output, aggregate, results.dataType), task.order));\n      } else {\n        onSuccess(getOutput(task.output, aggregate, results.dataType));\n      }\n      if (hamsters.debug) {\n        console.info('Execution Complete! Elapsed: ' + (e.timeStamp - task.input[0].start) / 1000 + 's');\n      }\n      hamsters.pool.tasks[task.id] = null; //Clean up our task, not needed any longer\n      if (hamsters.cache && memoize) {\n        if (task.output[id] && !task.output[id].slice) {\n          memoize(task.fn, task.input[0].input, normalizeArray(output), results.dataType);\n        } else {\n          memoize(task.fn, task.input[0].input, getOutput(task.output, aggregate, results.dataType), results.dataType);\n        }\n      }\n    }\n    if (hamsters.pool.pending.length !== 0) {\n      processQueue(hamster, hamsters.pool.pending.shift());\n    } else if (!hamsters.persistence && !hamsters.habitat.worker) {\n      hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)\n    }\n  };\n\n  function onerror(e) {\n    if (!hamsters.habitat.worker) {\n      hamster.terminate(); //Kill the thread\n    }\n    hamsters.pool.errors.push({\n      msg: 'Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message\n    });\n    console.error('Error Hamster #' + id + ': Line ' + e.lineno + ' in ' + e.filename + ': ' + e.message);\n  };\n\n  if (hamsters.habitat.worker) {\n    hamster.port.onmessage = onmessage;\n    hamster.port.onerror = onerror;\n  } else {\n    hamster.onmessage = onmessage;\n    hamster.onerror = onerror;\n  }\n}\n\nfunction processData(dataType, buffer) {\n  var types = {\n    'uint32': Uint32Array,\n    'uint16': Uint16Array,\n    'uint8': Uint8Array,\n    'uint8clamped': Uint8ClampedArray,\n    'int32': Int32Array,\n    'int16': Int16Array,\n    'int8': Int8Array,\n    'float32': Float32Array,\n    'float64': Float64Array\n  };\n  if (!types[dataType]) {\n    return dataType;\n  }\n  return new types[dataType](buffer);\n}\n\nfunction processDataType(dataType, buffer) {\n  if (hamsters.habitat.transferrable) {\n    return processData(dataType, buffer);\n  }\n  return buffer;\n}\n\nfunction feedHamster(hamster, food) {\n  if (hamsters.habitat.worker) {\n    return hamster.port.postMessage(food);\n  }\n  if (hamsters.habitat.ie10) {\n    return hamster.postMessage(food);\n  }\n  var buffers = [],\n      key = void 0;\n  for (key in food) {\n    if (food.hasOwnProperty(key) && food[key] && food[key].buffer) {\n      buffers.push(food[key].buffer);\n    }\n  }\n  return hamster.postMessage(food, buffers);\n}\n\nif (true) {\n  module.exports = hamsters;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../process/browser.js */ 11), __webpack_require__(/*! ./../../webpack/buildin/global.js */ 12)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFtc3RlcnMuanMvYnVpbGQvaGFtc3RlcnMuanM/MDBjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBUaXRsZTogSGFtc3RlcnMuanNcbiogRGVzY3JpcHRpb246IEphdmFzY3JpcHQgbGlicmFyeSB0byBhZGQgbXVsdGktdGhyZWFkaW5nIHN1cHBvcnQgdG8gamF2YXNjcmlwdCBieSBleHBsb2l0aW5nIGNvbmN1cnJlbnQgd2ViIHdvcmtlcnNcbiogQXV0aG9yOiBBdXN0aW4gSy4gU21pdGhcbiogQ29udGFjdDogYXVzdGluQGFzbWl0aGRldi5jb21cbiogQ29weXJpZ2h0OiAyMDE1IEF1c3RpbiBLLiBTbWl0aCAtIGF1c3RpbkBhc21pdGhkZXYuY29tXG4qIExpY2Vuc2U6IEFydGlzdGljIExpY2Vuc2UgMi4wXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIGhhbXN0ZXJzID0ge1xuICB2ZXJzaW9uOiAnNC4yLjEnLFxuICBkZWJ1ZzogZmFsc2UsXG4gIGNhY2hlOiBmYWxzZSxcbiAgcGVyc2lzdGVuY2U6IHRydWUsXG4gIG1heFRocmVhZHM6IDQsXG4gIGF0b21pY3M6IGZhbHNlLFxuICBoYWJpdGF0OiB7XG4gICAgbGVnYWN5OiBmYWxzZSxcbiAgICBub2RlOiBmYWxzZSxcbiAgICBzaGVsbDogZmFsc2UsXG4gICAgd29ya2VyOiBmYWxzZSxcbiAgICBicm93c2VyOiBmYWxzZSxcbiAgICBpZTEwOiBmYWxzZSxcbiAgICBhdG9taWNzOiBmYWxzZSxcbiAgICB0cmFuc2ZlcnJhYmxlOiB0cnVlXG4gIH0sXG4gIHRvb2xzOiB7fSxcbiAgcG9vbDoge1xuICAgIGVycm9yczogW10sXG4gICAgdGFza3M6IFtdLFxuICAgIHRocmVhZHM6IFtdLFxuICAgIHJ1bm5pbmc6IFtdLFxuICAgIHBlbmRpbmc6IFtdXG4gIH0sXG4gIHVyaTogbnVsbFxufTtcblxuaGFtc3RlcnMuaW5pdCA9IGZ1bmN0aW9uIChzdGFydE9wdGlvbnMpIHtcbiAgc2V0dXBIYW1zdGVyc0Vudmlyb25tZW50KHN0YXJ0T3B0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYW1zdGVycy5oYWJpdGF0LmxlZ2FjeSkge1xuICAgICAgaGFtc3RlcnMucG9vbC5uZXdXaGVlbCA9IGxlZ2FjeUhhbXN0ZXJXaGVlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFtc3RlcnMucG9vbC5uZXdXaGVlbCA9IGhhbXN0ZXJXaGVlbDtcbiAgICAgIHNwYXduSGFtc3RlcnMoKTtcbiAgICB9XG4gICAgY2hld0dhcmJhZ2Uoc3RhcnRPcHRpb25zKTtcbiAgfSk7XG4gIGhhbXN0ZXJzLnJ1biA9IHJ1bkhhbXN0ZXI7XG4gIGhhbXN0ZXJzLnRvb2xzLnJhbmRvbUFycmF5ID0gcmFuZG9tQXJyYXk7XG4gIGhhbXN0ZXJzLnRvb2xzLmxvb3AgPSBsb29wO1xuICBoYW1zdGVycy50b29scy5wYXJzZUpzb24gPSBwYXJzZUpzb25PblRocmVhZDtcbiAgaGFtc3RlcnMudG9vbHMuc3RyaW5naWZ5SnNvbiA9IHN0cmluZ2lmeUpzb25PblRocmVhZDtcbn07XG5cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnbXNpZScgKyAoIWlzTmFOKHZlcnNpb24pID8gJ1xcXFxzJyArIHZlcnNpb24gOiAnJyksICdpJykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0dXBCcm93c2VyU3VwcG9ydCgpIHtcbiAgaWYgKCFXb3JrZXIgfHwgWydLaW5kbGUvMy4wJywgJ01vYmlsZS84RjE5MCcsICdJRU1vYmlsZSddLmluZGV4T2YobmF2aWdhdG9yLnVzZXJBZ2VudCkgIT09IC0xKSB7XG4gICAgaGFtc3RlcnMuaGFiaXRhdC5sZWdhY3kgPSB0cnVlO1xuICB9XG4gIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSkge1xuICAgIGhhbXN0ZXJzLm1heFRocmVhZHMgPSBoYW1zdGVycy5tYXhUaHJlYWRzID4gMjAgPyAyMCA6IGhhbXN0ZXJzLm1heFRocmVhZHM7XG4gIH1cbiAgaWYgKGlzSUUoMTApKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ZXN0VGhyZWFkID0gbmV3IFdvcmtlcignc3JjL2NvbW1vbi93aGVlbC5taW4uanMnKTtcbiAgICAgIHRlc3RUaHJlYWQudGVybWluYXRlKCk7XG4gICAgICBoYW1zdGVycy5oYWJpdGF0LmllMTAgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbXN0ZXJzLmhhYml0YXQubGVnYWN5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBXb3JrZXJTdXBwb3J0KCkge1xuICB0cnkge1xuICAgIHZhciB3b3JrZXJCbG9iID0gZ2VuZXJhdGVXb3JrZXJCbG9iKCk7XG4gICAgdmFyIFNoYXJlZEhhbXN0ZXIgPSBuZXcgU2hhcmVkV29ya2VyKHdvcmtlckJsb2IsICdTaGFyZWRIYW1zdGVyV2hlZWwnKTtcbiAgICBoYW1zdGVycy51cmkgPSB3b3JrZXJCbG9iO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFtc3RlcnMuaGFiaXRhdC5sZWdhY3kgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTdGFydE9wdGlvbnMoc3RhcnRPcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzdGFydE9wdGlvbnMpIHtcbiAgICBpZiAoc3RhcnRPcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGhhbXN0ZXJzW2tleV0gPSBzdGFydE9wdGlvbnNba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBIYW1zdGVyc0Vudmlyb25tZW50KHN0YXJ0T3B0aW9ucywgb25TdWNjZXNzKSB7XG4gIGhhbXN0ZXJzLmhhYml0YXQuYnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIjtcbiAgaGFtc3RlcnMuaGFiaXRhdC53b3JrZXIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gXCJmdW5jdGlvblwiO1xuICBoYW1zdGVycy5oYWJpdGF0Lm5vZGUgPSAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb2Nlc3MpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmICFoYW1zdGVycy5oYWJpdGF0LmJyb3dzZXIgJiYgIWhhbXN0ZXJzLmhhYml0YXQud29ya2VyICYmICFoYW1zdGVycy5oYWJpdGF0LnJlYWN0TmF0aXZlO1xuICBoYW1zdGVycy5oYWJpdGF0LnJlYWN0TmF0aXZlID0gIWhhbXN0ZXJzLmhhYml0YXQubm9kZSAmJiAodHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZ2xvYmFsKSkgPT09ICdvYmplY3QnO1xuICBoYW1zdGVycy5oYWJpdGF0LnNoZWxsID0gIWhhbXN0ZXJzLmhhYml0YXQuYnJvd3NlciAmJiAhaGFtc3RlcnMuaGFiaXRhdC5ub2RlICYmICFoYW1zdGVycy5oYWJpdGF0LndvcmtlciAmJiAhaGFtc3RlcnMuaGFiaXRhdC5yZWFjdE5hdGl2ZTtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBoYW1zdGVycy5tYXhUaHJlYWRzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydE9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcHJvY2Vzc1N0YXJ0T3B0aW9ucyhzdGFydE9wdGlvbnMpO1xuICB9XG4gIGlmIChoYW1zdGVycy5oYWJpdGF0LmJyb3dzZXIgJiYgIWhhbXN0ZXJzLmhhYml0YXQucmVhY3ROYXRpdmUpIHtcbiAgICBzZXR1cEJyb3dzZXJTdXBwb3J0KCk7XG4gIH1cbiAgaWYgKGhhbXN0ZXJzLmhhYml0YXQud29ya2VyKSB7XG4gICAgc2V0dXBXb3JrZXJTdXBwb3J0KCk7XG4gIH1cbiAgaWYgKGhhbXN0ZXJzLmhhYml0YXQubm9kZSB8fCBoYW1zdGVycy5oYWJpdGF0LnJlYWN0TmF0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiBoYW1zdGVycy5Xb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuV29ya2VyID0gaGFtc3RlcnMuV29ya2VyO1xuICAgIH1cbiAgfVxuICBpZiAoaGFtc3RlcnMuaGFiaXRhdC5zaGVsbCB8fCB0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGhhbXN0ZXJzLmhhYml0YXQubGVnYWN5ID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaGFtc3RlcnMuaGFiaXRhdC50cmFuc2ZlcnJhYmxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBoYW1zdGVycy5oYWJpdGF0LmF0b21pY3MgPSB0cnVlO1xuICB9XG4gIG9uU3VjY2VzcygpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGNyZWF0ZUJsb2IoJygnICsgU3RyaW5nKGdpdmVIYW1zdGVyV29yaygpKSArICcpKCk7JykpO1xufVxuXG5mdW5jdGlvbiBzcGF3bkhhbXN0ZXJzKCkge1xuICBpZiAoaGFtc3RlcnMuaGFiaXRhdC5icm93c2VyKSB7XG4gICAgaGFtc3RlcnMudXJpID0gZ2VuZXJhdGVXb3JrZXJCbG9iKCk7XG4gIH1cbiAgaWYgKGhhbXN0ZXJzLnBlcnNpc3RlbmNlKSB7XG4gICAgdmFyIGkgPSBoYW1zdGVycy5tYXhUaHJlYWRzO1xuICAgIGZvciAoaTsgaSA+IDA7IGktLSkge1xuICAgICAgaGFtc3RlcnMucG9vbC50aHJlYWRzLnB1c2goc3Bhd25IYW1zdGVyKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzcGF3bkhhbXN0ZXIoKSB7XG4gIGlmIChoYW1zdGVycy5oYWJpdGF0LmllMTApIHtcbiAgICByZXR1cm4gbmV3IFdvcmtlcignc3JjL2NvbW1vbi93aGVlbC5taW4uanMnKTtcbiAgfSBlbHNlIGlmIChoYW1zdGVycy5oYWJpdGF0Lndvcmtlcikge1xuICAgIHJldHVybiBuZXcgU2hhcmVkV29ya2VyKGhhbXN0ZXJzLnVyaSwgJ1NoYXJlZEhhbXN0ZXJXaGVlbCcpO1xuICB9IGVsc2UgaWYgKGhhbXN0ZXJzLmhhYml0YXQubm9kZSkge1xuICAgIHJldHVybiBuZXcgV29ya2VyKGdpdmVIYW1zdGVyV29yaygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFdvcmtlcihoYW1zdGVycy51cmkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdpdmVIYW1zdGVyV29yaygpIHtcbiAgaWYgKGhhbXN0ZXJzLmhhYml0YXQud29ya2VyKSB7XG4gICAgcmV0dXJuIHdvcmtlcldvcmtlcjtcbiAgfVxuICByZXR1cm4gd29ya2VyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCbG9iKHRleHRDb250ZW50KSB7XG4gIGlmICghQmxvYikge1xuICAgIHZhciBCbG9iTWFrZXIgPSBCbG9iQnVpbGRlciB8fCBXZWJLaXRCbG9iQnVpbGRlciB8fCBNb3pCbG9iQnVpbGRlciB8fCBNU0Jsb2JCdWlsZGVyO1xuICAgIHZhciBibG9iID0gbmV3IEJsb2JNYWtlcigpO1xuICAgIGJsb2IuYXBwZW5kKFt0ZXh0Q29udGVudF0sIHtcbiAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICAgIH0pO1xuICAgIHJldHVybiBibG9iLmdldEJsb2IoKTtcbiAgfVxuICByZXR1cm4gbmV3IEJsb2IoW3RleHRDb250ZW50XSwge1xuICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd29ya2VyV29ya2VyKCkge1xuICBhZGRFdmVudExpc3RlbmVyKFwiY29ubmVjdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwb3J0ID0gZS5wb3J0c1swXTtcbiAgICBwb3J0LnN0YXJ0KCk7XG4gICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgc2VsZi5wYXJhbXMgPSBlLmRhdGE7XG4gICAgICBzZWxmLnJ0biA9IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFUeXBlOiBwYXJhbXMuZGF0YVR5cGVcbiAgICAgIH07XG4gICAgICB2YXIgZm4gPSBldmFsKFwiKFwiICsgcGFyYW1zLmZuICsgXCIpXCIpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9XG4gICAgICBwb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgcmVzdWx0czogcnRuXG4gICAgICB9KTtcbiAgICB9LCBmYWxzZSk7XG4gIH0sIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gd29ya2VyKCkge1xuICBmdW5jdGlvbiBwcm9jZXNzRGF0YVR5cGUoZGF0YVR5cGUsIGJ1ZmZlcikge1xuICAgIHZhciB0eXBlcyA9IHtcbiAgICAgICd1aW50MzInOiBVaW50MzJBcnJheSxcbiAgICAgICd1aW50MTYnOiBVaW50MTZBcnJheSxcbiAgICAgICd1aW50OCc6IFVpbnQ4QXJyYXksXG4gICAgICAndWludDhjbGFtcGVkJzogVWludDhDbGFtcGVkQXJyYXksXG4gICAgICAnaW50MzInOiBJbnQzMkFycmF5LFxuICAgICAgJ2ludDE2JzogSW50MTZBcnJheSxcbiAgICAgICdpbnQ4JzogSW50OEFycmF5LFxuICAgICAgJ2Zsb2F0MzInOiBGbG9hdDMyQXJyYXksXG4gICAgICAnZmxvYXQ2NCc6IEZsb2F0NjRBcnJheVxuICAgIH07XG4gICAgaWYgKCF0eXBlc1tkYXRhVHlwZV0pIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdHlwZXNbZGF0YVR5cGVdKGJ1ZmZlcik7XG4gIH1cblxuICBvbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbm1lc3NhZ2UoZSkge1xuICAgIHNlbGYucGFyYW1zID0gZS5kYXRhO1xuICAgIHNlbGYucnRuID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBkYXRhVHlwZTogcGFyYW1zLmRhdGFUeXBlXG4gICAgfTtcbiAgICB2YXIgZm4gPSBuZXcgRnVuY3Rpb24ocGFyYW1zLmZuKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuZGF0YVR5cGUpIHtcbiAgICAgIHJ0bi5kYXRhID0gcHJvY2Vzc0RhdGFUeXBlKHBhcmFtcy5kYXRhVHlwZSwgcnRuLmRhdGEpO1xuICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICByZXN1bHRzOiBydG5cbiAgICAgIH0sIFtydG4uZGF0YS5idWZmZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICByZXN1bHRzOiBydG5cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvL0dhcmJhZ2UgY29sbGVjdGlvblxuICAgIHNlbGYucGFyYW1zID0gdW5kZWZpbmVkO1xuICAgIHNlbGYucnRuID0gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lIYW1zdGVyV2hlZWwoaW5wdXRBcnJheSwgaGFtc3RlckZvb2QsIGFnZ3JlZ2F0ZSwgb25TdWNjZXNzLCB0YXNrLCB0aHJlYWRfaWQsIGhhbXN0ZXIsIG1lbW9pemUpIHtcbiAgdHJhY2tUaHJlYWQodGFzaywgaGFtc3RlcnMucG9vbC5ydW5uaW5nLCB0aHJlYWRfaWQpO1xuICBpZiAobWVtb2l6ZSB8fCBoYW1zdGVycy5kZWJ1Zykge1xuICAgIHRyYWNrSW5wdXQoaW5wdXRBcnJheSwgdGhyZWFkX2lkLCB0YXNrLCBoYW1zdGVyRm9vZCk7XG4gIH1cbiAgbGVnYWN5UHJvY2Vzc29yKGhhbXN0ZXJGb29kLCBpbnB1dEFycmF5LCBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgY2xlYW4odGFzaywgdGhyZWFkX2lkKTtcbiAgICB0YXNrLm91dHB1dFt0aHJlYWRfaWRdID0gb3V0cHV0LmRhdGE7XG4gICAgaWYgKHRhc2sud29ya2Vycy5sZW5ndGggPT09IDAgJiYgdGFzay5jb3VudCA9PT0gdGFzay50aHJlYWRzKSB7XG4gICAgICBvblN1Y2Nlc3MoZ2V0T3V0cHV0KHRhc2sub3V0cHV0LCBhZ2dyZWdhdGUsIG91dHB1dC5kYXRhVHlwZSkpO1xuICAgICAgaGFtc3RlcnMucG9vbC50YXNrc1t0YXNrLmlkXSA9IG51bGw7XG4gICAgICBpZiAoaGFtc3RlcnMuY2FjaGUgJiYgbWVtb2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgbWVtb2l6ZSh0YXNrLmZuLCB0YXNrLmlucHV0LCBvdXRwdXQuZGF0YSwgb3V0cHV0LmRhdGFUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0YXNrLmNvdW50ICs9IDE7IC8vVGhyZWFkIGZpbmlzaGVkXG59XG5cbmZ1bmN0aW9uIGhhbXN0ZXJXaGVlbChpbnB1dEFycmF5LCBoYW1zdGVyRm9vZCwgYWdncmVnYXRlLCBvblN1Y2Nlc3MsIHRhc2ssIHRocmVhZF9pZCwgaGFtc3RlciwgbWVtb2l6ZSkge1xuICBpZiAoaGFtc3RlcnMubWF4VGhyZWFkcyA9PT0gaGFtc3RlcnMucG9vbC5ydW5uaW5nLmxlbmd0aCkge1xuICAgIHBvb2xUaHJlYWQoaW5wdXRBcnJheSwgaGFtc3RlckZvb2QsIHRocmVhZF9pZCwgb25TdWNjZXNzLCB0YXNrLCBhZ2dyZWdhdGUsIG1lbW9pemUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobWVtb2l6ZSB8fCBoYW1zdGVycy5kZWJ1Zykge1xuICAgIHRyYWNrSW5wdXQoaW5wdXRBcnJheSwgdGhyZWFkX2lkLCB0YXNrLCBoYW1zdGVyRm9vZCk7XG4gIH1cbiAgaWYgKCFoYW1zdGVyKSB7XG4gICAgaWYgKGhhbXN0ZXJzLnBlcnNpc3RlbmNlKSB7XG4gICAgICBoYW1zdGVyID0gaGFtc3RlcnMucG9vbC50aHJlYWRzW2hhbXN0ZXJzLnBvb2wucnVubmluZy5sZW5ndGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW1zdGVyID0gc3Bhd25IYW1zdGVyKCk7XG4gICAgfVxuICB9XG4gIHRyYWluSGFtc3Rlcih0aHJlYWRfaWQsIGFnZ3JlZ2F0ZSwgb25TdWNjZXNzLCB0YXNrLCBoYW1zdGVyLCBtZW1vaXplKTtcbiAgdHJhY2tUaHJlYWQodGFzaywgaGFtc3RlcnMucG9vbC5ydW5uaW5nLCB0aHJlYWRfaWQpO1xuICBoYW1zdGVyRm9vZC5hcnJheSA9IGlucHV0QXJyYXk7XG4gIGZlZWRIYW1zdGVyKGhhbXN0ZXIsIGhhbXN0ZXJGb29kKTtcbiAgdGFzay5jb3VudCArPSAxOyAvL0luY3JlbWVudCBjb3VudCwgdGhyZWFkIGlzIHJ1bm5pbmdcbiAgaWYgKGhhbXN0ZXJzLmRlYnVnID09PSAndmVyYm9zZScpIHtcbiAgICBjb25zb2xlLmluZm8oJ1NwYXduaW5nIEhhbXN0ZXIgIycgKyB0aHJlYWRfaWQgKyAnIEAgJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGV3R2FyYmFnZShzdGFydE9wdGlvbnMpIHtcbiAgZGVsZXRlIGhhbXN0ZXJzLmluaXQ7XG4gIHN0YXJ0T3B0aW9ucyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNwbGl0QXJyYXkoYXJyYXksIG4pIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgdGhyZWFkQXJyYXlzID0gW107XG4gIHZhciBzaXplID0gTWF0aC5jZWlsKGFycmF5Lmxlbmd0aCAvIG4pO1xuICBpZiAoYXJyYXkuc2xpY2UpIHtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgdGhyZWFkQXJyYXlzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArPSBzaXplKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aHJlYWRBcnJheXMucHVzaChhcnJheS5zdWJhcnJheShpLCBpICs9IHNpemUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRocmVhZEFycmF5cztcbn1cblxuZnVuY3Rpb24gbG9vcChpbnB1dCwgb25TdWNjZXNzKSB7XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgcnVuOiBwcmVwYXJlRnVuY3Rpb24oaW5wdXQub3BlcmF0b3IpLFxuICAgIGluaXQ6IGlucHV0LnN0YXJ0SW5kZXggfHwgMCxcbiAgICBsaW1pdDogaW5wdXQubGltaXQsXG4gICAgYXJyYXk6IGlucHV0LmFycmF5LFxuICAgIGluY3JlbWVudEJ5OiBpbnB1dC5pbmNyZW1lbnRCeSB8fCAxLFxuICAgIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZSB8fCBudWxsLFxuICAgIHdvcmtlcjogaGFtc3RlcnMuaGFiaXRhdC53b3JrZXJcbiAgfTtcbiAgcnVuSGFtc3RlcihwYXJhbXMsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBwYXJhbXMucnVuO1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChwYXJhbXMud29ya2VyKSB7XG4gICAgICAgIG9wZXJhdG9yID0gZXZhbChcIihcIiArIG9wZXJhdG9yICsgXCIpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BlcmF0b3IgPSBuZXcgRnVuY3Rpb24ob3BlcmF0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5saW1pdCkge1xuICAgICAgcGFyYW1zLmxpbWl0ID0gcGFyYW1zLmFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGkgPSBwYXJhbXMuaW5pdDtcbiAgICBmb3IgKGk7IGkgPCBwYXJhbXMubGltaXQ7IGkgKz0gcGFyYW1zLmluY3JlbWVudEJ5KSB7XG4gICAgICBydG4uZGF0YVtpXSA9IG9wZXJhdG9yKHBhcmFtcy5hcnJheVtpXSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAocnRuKSB7XG4gICAgb25TdWNjZXNzKHJ0bik7XG4gIH0sIGlucHV0LnRocmVhZHMsIDEsIGlucHV0LmRhdGFUeXBlKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZ1bmN0aW9uKGZ1bmN0aW9uQm9keSkge1xuICBpZiAoIWhhbXN0ZXJzLmhhYml0YXQubGVnYWN5KSB7XG4gICAgZnVuY3Rpb25Cb2R5ID0gU3RyaW5nKGZ1bmN0aW9uQm9keSk7XG4gICAgaWYgKCFoYW1zdGVycy5oYWJpdGF0Lndvcmtlcikge1xuICAgICAgdmFyIHN0YXJ0aW5nSW5kZXggPSBmdW5jdGlvbkJvZHkuaW5kZXhPZihcIntcIikgKyAxO1xuICAgICAgdmFyIGVuZGluZ0luZGV4ID0gZnVuY3Rpb25Cb2R5Lmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Cb2R5LnN1YnN0cmluZyhzdGFydGluZ0luZGV4LCBlbmRpbmdJbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbkJvZHk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSnNvbk9uVGhyZWFkKHN0cmluZywgb25TdWNjZXNzKSB7XG4gIHJ1bkhhbXN0ZXIoeyBpbnB1dDogc3RyaW5nIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBydG4uZGF0YSA9IEpTT04ucGFyc2UocGFyYW1zLmlucHV0KTtcbiAgfSwgZnVuY3Rpb24gKG91dHB1dCkge1xuICAgIG9uU3VjY2VzcyhvdXRwdXRbMF0pO1xuICB9LCAxKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5SnNvbk9uVGhyZWFkKGpzb24sIG9uU3VjY2Vzcykge1xuICBydW5IYW1zdGVyKHsgaW5wdXQ6IGpzb24gfSwgZnVuY3Rpb24gKCkge1xuICAgIHJ0bi5kYXRhID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zLmlucHV0KTtcbiAgfSwgZnVuY3Rpb24gKG91dHB1dCkge1xuICAgIG9uU3VjY2VzcyhvdXRwdXRbMF0pO1xuICB9LCAxKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tQXJyYXkoY291bnQsIG9uU3VjY2Vzcykge1xuICB2YXIgcGFyYW1zID0ge1xuICAgIGNvdW50OiBjb3VudFxuICB9O1xuICBydW5IYW1zdGVyKHBhcmFtcywgZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlIChwYXJhbXMuY291bnQgPiAwKSB7XG4gICAgICBydG4uZGF0YVtydG4uZGF0YS5sZW5ndGhdID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDEwMCAtIDEpICsgMSk7XG4gICAgICBwYXJhbXMuY291bnQgLT0gMTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBvblN1Y2Nlc3MocmVzdWx0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVRocmVhZE91dHB1dHMoaW5wdXQsIGRhdGFUeXBlKSB7XG4gIGlmICghZGF0YVR5cGUgfHwgIWhhbXN0ZXJzLmhhYml0YXQudHJhbnNmZXJyYWJsZSkge1xuICAgIHJldHVybiBpbnB1dC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIHZhciBidWZmZXJMZW5ndGggPSAwO1xuICBmb3IgKGk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGJ1ZmZlckxlbmd0aCArPSBpbnB1dFtpXS5sZW5ndGg7XG4gIH1cbiAgdmFyIG91dHB1dCA9IHByb2Nlc3NEYXRhVHlwZShkYXRhVHlwZSwgYnVmZmVyTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIG91dHB1dC5zZXQoaW5wdXRbaV0sIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGlucHV0W2ldLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja0NhY2hlKGZuLCBpbnB1dCwgZGF0YVR5cGUpIHtcbiAgdmFyIGNhY2hlZFJlc3VsdCA9IGhhbXN0ZXJzLmNhY2hlW2ZuXTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIGlmIChjYWNoZWRSZXN1bHRbMF0gPT09IGlucHV0ICYmIGNhY2hlZFJlc3VsdFsyXSA9PT0gZGF0YVR5cGUpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUoZm4sIGlucHV0QXJyYXksIG91dHB1dCwgZGF0YVR5cGUpIHtcbiAgaGFtc3RlcnMuY2FjaGVbZm5dID0gW2lucHV0QXJyYXksIG91dHB1dCwgZGF0YVR5cGVdO1xufVxuXG5mdW5jdGlvbiBzb3J0KGFyciwgb3JkZXIpIHtcbiAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgJ2Rlc2MnOlxuICAgIGNhc2UgJ2FzYyc6XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvcnQuY2FsbChhcnIsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBvcmRlciA9PT0gJ2FzYycgPyBhIC0gYiA6IGIgLSBhO1xuICAgICAgfSk7XG4gICAgY2FzZSAnYXNjQWxwaGEnOlxuICAgICAgcmV0dXJuIGFyci5zb3J0KCk7XG4gICAgY2FzZSAnZGVzY0FscGhhJzpcbiAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkhhbXN0ZXIocGFyYW1zLCBmbiwgb25TdWNjZXNzLCB3b3JrZXJzLCBhZ2dyZWdhdGUsIGRhdGFUeXBlLCBtZW1vaXplLCBvcmRlcikge1xuICBpZiAoIXBhcmFtcyB8fCAhZm4pIHtcbiAgICByZXR1cm4gJ0Vycm9yIHByb2Nlc3NpbmcgZm9yIGxvb3AsIG1pc3NpbmcgcGFyYW1zIG9yIGZ1bmN0aW9uJztcbiAgfVxuICB3b3JrZXJzID0gaGFtc3RlcnMuaGFiaXRhdC5sZWdhY3kgPyAxIDogd29ya2VycyB8fCAxO1xuICB2YXIgdGFzayA9IG5ld1Rhc2soaGFtc3RlcnMucG9vbC50YXNrcy5sZW5ndGgsIHdvcmtlcnMsIG9yZGVyLCBkYXRhVHlwZSwgZm4sIG9uU3VjY2Vzcyk7XG4gIGlmIChkYXRhVHlwZSkge1xuICAgIGRhdGFUeXBlID0gZGF0YVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpZiAoaGFtc3RlcnMuY2FjaGUgJiYgbWVtb2l6ZSkge1xuICAgIHZhciByZXN1bHQgPSBjaGVja0NhY2hlKGZuLCB0YXNrLmlucHV0LCBkYXRhVHlwZSk7XG4gICAgaWYgKHJlc3VsdCAmJiBvblN1Y2Nlc3MpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW1zdGVycy5wb29sLnRhc2tzW3Rhc2tpZF0gPSBudWxsOyAvL0NsZWFuIHVwIG91ciB0YXNrLCBub3QgbmVlZGVkIGFueSBsb25nZXJcbiAgICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgICB9LCA0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgd29yayh0YXNrLCBwYXJhbXMsIGZuLCBvblN1Y2Nlc3MsIGFnZ3JlZ2F0ZSwgZGF0YVR5cGUsIG1lbW9pemUsIG9yZGVyKTtcbn1cblxuZnVuY3Rpb24gd29yayh0YXNrLCBwYXJhbXMsIGZuLCBvblN1Y2Nlc3MsIGFnZ3JlZ2F0ZSwgZGF0YVR5cGUsIG1lbW9pemUsIG9yZGVyKSB7XG4gIHZhciB3b3JrQXJyYXkgPSBwYXJhbXMuYXJyYXk7XG4gIGlmICh3b3JrQXJyYXkgJiYgdGFzay50aHJlYWRzICE9PSAxKSB7XG4gICAgd29ya0FycmF5ID0gc3BsaXRBcnJheSh3b3JrQXJyYXksIHRhc2sudGhyZWFkcyk7IC8vRGl2aWRlIG91ciBhcnJheSBpbnRvIGVxdWFsIGFycmF5IHNpemVzXG4gIH1cbiAgdmFyIGZvb2QgPSB7fTtcbiAgdmFyIGtleSA9IHZvaWQgMDtcbiAgZm9yIChrZXkgaW4gcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ2FycmF5Jykge1xuICAgICAgZm9vZFtrZXldID0gcGFyYW1zW2tleV07XG4gICAgfVxuICB9XG4gIGZvb2QuZm4gPSBwcmVwYXJlRnVuY3Rpb24oZm4pO1xuICBmb29kLmRhdGFUeXBlID0gZGF0YVR5cGU7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCB0YXNrLnRocmVhZHMpIHtcbiAgICBpZiAod29ya0FycmF5ICYmIHRhc2sudGhyZWFkcyAhPT0gMSkge1xuICAgICAgaGFtc3RlcnMucG9vbC5uZXdXaGVlbCh3b3JrQXJyYXlbaV0sIGZvb2QsIGFnZ3JlZ2F0ZSwgb25TdWNjZXNzLCB0YXNrLCB0YXNrLmNvdW50LCBudWxsLCBtZW1vaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFtc3RlcnMucG9vbC5uZXdXaGVlbCh3b3JrQXJyYXksIGZvb2QsIGFnZ3JlZ2F0ZSwgb25TdWNjZXNzLCB0YXNrLCB0YXNrLmNvdW50LCBudWxsLCBtZW1vaXplKTtcbiAgICB9XG4gICAgaSArPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5ld1Rhc2sodGFza2lkLCB3b3JrZXJzLCBvcmRlciwgZGF0YVR5cGUsIGZuLCBjYikge1xuICBoYW1zdGVycy5wb29sLnRhc2tzLnB1c2goe1xuICAgIGlkOiB0YXNraWQsXG4gICAgd29ya2VyczogW10sXG4gICAgY291bnQ6IDAsXG4gICAgdGhyZWFkczogd29ya2VycyxcbiAgICBpbnB1dDogW10sXG4gICAgZGF0YVR5cGU6IGRhdGFUeXBlIHx8IG51bGwsXG4gICAgZm46IGZuLFxuICAgIG91dHB1dDogW10sXG4gICAgb3JkZXI6IG9yZGVyIHx8IG51bGwsXG4gICAgb25TdWNjZXNzOiBjYlxuICB9KTtcbiAgcmV0dXJuIGhhbXN0ZXJzLnBvb2wudGFza3NbdGFza2lkXTtcbn1cblxuZnVuY3Rpb24gYXNzaWduT3V0cHV0KHRhc2ssIGlucHV0QXJyYXkpIHtcbiAgaWYgKCF0YXNrIHx8ICFpbnB1dEFycmF5IHx8ICFoYW1zdGVycy5oYWJpdGF0LmF0b21pY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGFzay5vdXRwdXQgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoaW5wdXRBcnJheS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiB0cmFja0lucHV0KGlucHV0QXJyYXksIHRocmVhZF9pZCwgdGFzaywgaGFtc3RlckZvb2QpIHtcbiAgdGFzay5pbnB1dC5wdXNoKHtcbiAgICBpbnB1dDogaW5wdXRBcnJheSxcbiAgICB3b3JrZXJpZDogdGhyZWFkX2lkLFxuICAgIHRhc2tpZDogdGFzay5pZCxcbiAgICBwYXJhbXM6IGhhbXN0ZXJGb29kLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhY2tUaHJlYWQodGFzaywgcnVubmluZywgaWQpIHtcbiAgdGFzay53b3JrZXJzLnB1c2goaWQpOyAvL0tlZXAgdHJhY2sgb2YgdGhyZWFkcyBzY29wZWQgdG8gY3VycmVudCB0YXNrXG4gIHJ1bm5pbmcucHVzaChpZCk7IC8vS2VlcCB0cmFjayBvZiBhbGwgY3VycmVudGx5IHJ1bm5pbmcgdGhyZWFkc1xufVxuXG5mdW5jdGlvbiBwb29sVGhyZWFkKGlucHV0QXJyYXksIGhhbXN0ZXJGb29kLCB0aHJlYWRfaWQsIGNiLCB0YXNrLCBhZ2csIG1lbW9pemUpIHtcbiAgaGFtc3RlcnMucG9vbC5wZW5kaW5nLnB1c2goe1xuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgaW5wdXQ6IGlucHV0QXJyYXksXG4gICAgcGFyYW1zOiBoYW1zdGVyRm9vZCxcbiAgICB3b3JrZXJpZDogdGhyZWFkX2lkLFxuICAgIG9uU3VjY2VzczogY2IsXG4gICAgdGFzazogdGFzayxcbiAgICBhZ2dyZWdhdGU6IGFnZ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbGVnYWN5UHJvY2Vzc29yKHBhcmFtcywgaW5wdXRBcnJheSwgb25TdWNjZXNzKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBydG4gPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogW11cbiAgICB9O1xuICAgIHZhciBwYXJhbXMgPSBwYXJhbXM7XG4gICAgcGFyYW1zLmFycmF5ID0gaW5wdXRBcnJheTtcbiAgICBwYXJhbXMuZm4oKTtcbiAgICBpZiAocGFyYW1zLmRhdGFUeXBlICYmIHBhcmFtcy5kYXRhVHlwZSAhPSBcIm5hXCIpIHtcbiAgICAgIHJ0bi5kYXRhID0gcHJvY2Vzc0RhdGFUeXBlKHBhcmFtcy5kYXRhVHlwZSwgcnRuLmRhdGEpO1xuICAgICAgcnRuLmRhdGFUeXBlID0gcGFyYW1zLmRhdGFUeXBlO1xuICAgIH1cbiAgICBvblN1Y2Nlc3MocnRuKTtcbiAgfSwgNCk7IC8vNG1zIGRlbGF5IChIVE1MNSBzcGVjIG1pbmltdW0pLCBzaW11bGF0ZSB0aHJlYWRpbmdcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0KG91dHB1dCwgYWdncmVnYXRlLCBkYXRhVHlwZSkge1xuICBpZiAoYWdncmVnYXRlICYmIG91dHB1dC5sZW5ndGggPD0gMjApIHtcbiAgICByZXR1cm4gYWdncmVnYXRlVGhyZWFkT3V0cHV0cyhvdXRwdXQsIGRhdGFUeXBlKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoaGFtc3RlciwgaXRlbSkge1xuICBpZiAoIWl0ZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFtc3RlcnMucG9vbC5uZXdXaGVlbChpdGVtLmlucHV0LCBpdGVtLnBhcmFtcywgaXRlbS5hZ2dyZWdhdGUsIGl0ZW0ub25TdWNjZXNzLCBpdGVtLnRhc2ssIGl0ZW0ud29ya2VyaWQsIGhhbXN0ZXIsIGl0ZW0ubWVtb2l6ZSk7IC8vQXNzaWduIG1vc3QgcmVjZW50bHkgZmluaXNoZWQgdGhyZWFkIHRvIHF1ZXVlIGl0ZW1cbn1cblxuZnVuY3Rpb24gY2xlYW4odGFzaywgaWQpIHtcbiAgaGFtc3RlcnMucG9vbC5ydW5uaW5nLnNwbGljZShoYW1zdGVycy5wb29sLnJ1bm5pbmcuaW5kZXhPZihpZCksIDEpOyAvL1JlbW92ZSB0aHJlYWQgZnJvbSBydW5uaW5nIHBvb2xcbiAgdGFzay53b3JrZXJzLnNwbGljZSh0YXNrLndvcmtlcnMuaW5kZXhPZihpZCksIDEpOyAvL1JlbW92ZSB0aHJlYWQgZnJvbSB0YXNrIHJ1bm5pbmcgcG9vbFxufVxuXG5mdW5jdGlvbiB0cmFpbkhhbXN0ZXIoaWQsIGFnZ3JlZ2F0ZSwgb25TdWNjZXNzLCB0YXNrLCBoYW1zdGVyLCBtZW1vaXplKSB7XG4gIGZ1bmN0aW9uIG9ubWVzc2FnZShlLCByZXN1bHRzKSB7XG4gICAgY2xlYW4odGFzaywgaWQpO1xuICAgIHJlc3VsdHMgPSBlLmRhdGEucmVzdWx0cztcbiAgICB0YXNrLm91dHB1dFtpZF0gPSByZXN1bHRzLmRhdGE7XG4gICAgaWYgKGhhbXN0ZXJzLmRlYnVnID09PSAndmVyYm9zZScpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnSGFtc3RlciAjJyArIGlkICsgJyBmaW5pc2hlZCAnICsgJ0AgJyArIGUudGltZVN0YW1wKTtcbiAgICB9XG4gICAgaWYgKHRhc2sud29ya2Vycy5sZW5ndGggPT09IDAgJiYgdGFzay5jb3VudCA9PT0gdGFzay50aHJlYWRzKSB7XG4gICAgICBpZiAodGFzay5vcmRlcikge1xuICAgICAgICBvblN1Y2Nlc3Moc29ydChnZXRPdXRwdXQodGFzay5vdXRwdXQsIGFnZ3JlZ2F0ZSwgcmVzdWx0cy5kYXRhVHlwZSksIHRhc2sub3JkZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uU3VjY2VzcyhnZXRPdXRwdXQodGFzay5vdXRwdXQsIGFnZ3JlZ2F0ZSwgcmVzdWx0cy5kYXRhVHlwZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGhhbXN0ZXJzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnRXhlY3V0aW9uIENvbXBsZXRlISBFbGFwc2VkOiAnICsgKGUudGltZVN0YW1wIC0gdGFzay5pbnB1dFswXS5zdGFydCkgLyAxMDAwICsgJ3MnKTtcbiAgICAgIH1cbiAgICAgIGhhbXN0ZXJzLnBvb2wudGFza3NbdGFzay5pZF0gPSBudWxsOyAvL0NsZWFuIHVwIG91ciB0YXNrLCBub3QgbmVlZGVkIGFueSBsb25nZXJcbiAgICAgIGlmIChoYW1zdGVycy5jYWNoZSAmJiBtZW1vaXplKSB7XG4gICAgICAgIGlmICh0YXNrLm91dHB1dFtpZF0gJiYgIXRhc2sub3V0cHV0W2lkXS5zbGljZSkge1xuICAgICAgICAgIG1lbW9pemUodGFzay5mbiwgdGFzay5pbnB1dFswXS5pbnB1dCwgbm9ybWFsaXplQXJyYXkob3V0cHV0KSwgcmVzdWx0cy5kYXRhVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVtb2l6ZSh0YXNrLmZuLCB0YXNrLmlucHV0WzBdLmlucHV0LCBnZXRPdXRwdXQodGFzay5vdXRwdXQsIGFnZ3JlZ2F0ZSwgcmVzdWx0cy5kYXRhVHlwZSksIHJlc3VsdHMuZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYW1zdGVycy5wb29sLnBlbmRpbmcubGVuZ3RoICE9PSAwKSB7XG4gICAgICBwcm9jZXNzUXVldWUoaGFtc3RlciwgaGFtc3RlcnMucG9vbC5wZW5kaW5nLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSBpZiAoIWhhbXN0ZXJzLnBlcnNpc3RlbmNlICYmICFoYW1zdGVycy5oYWJpdGF0Lndvcmtlcikge1xuICAgICAgaGFtc3Rlci50ZXJtaW5hdGUoKTsgLy9LaWxsIHRoZSB0aHJlYWQgb25seSBpZiBubyBpdGVtcyB3YWl0aW5nIHRvIHJ1biAoMjAtMjIlIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50IG9ic2VydmVkIGR1cmluZyB0ZXN0aW5nLCByZXB1cnBvc2luZyB0aHJlYWRzIHZzIHJlY3JlYXRpbmcgdGhlbSlcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gb25lcnJvcihlKSB7XG4gICAgaWYgKCFoYW1zdGVycy5oYWJpdGF0Lndvcmtlcikge1xuICAgICAgaGFtc3Rlci50ZXJtaW5hdGUoKTsgLy9LaWxsIHRoZSB0aHJlYWRcbiAgICB9XG4gICAgaGFtc3RlcnMucG9vbC5lcnJvcnMucHVzaCh7XG4gICAgICBtc2c6ICdFcnJvciBIYW1zdGVyICMnICsgaWQgKyAnOiBMaW5lICcgKyBlLmxpbmVubyArICcgaW4gJyArIGUuZmlsZW5hbWUgKyAnOiAnICsgZS5tZXNzYWdlXG4gICAgfSk7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgSGFtc3RlciAjJyArIGlkICsgJzogTGluZSAnICsgZS5saW5lbm8gKyAnIGluICcgKyBlLmZpbGVuYW1lICsgJzogJyArIGUubWVzc2FnZSk7XG4gIH07XG5cbiAgaWYgKGhhbXN0ZXJzLmhhYml0YXQud29ya2VyKSB7XG4gICAgaGFtc3Rlci5wb3J0Lm9ubWVzc2FnZSA9IG9ubWVzc2FnZTtcbiAgICBoYW1zdGVyLnBvcnQub25lcnJvciA9IG9uZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgaGFtc3Rlci5vbm1lc3NhZ2UgPSBvbm1lc3NhZ2U7XG4gICAgaGFtc3Rlci5vbmVycm9yID0gb25lcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRGF0YShkYXRhVHlwZSwgYnVmZmVyKSB7XG4gIHZhciB0eXBlcyA9IHtcbiAgICAndWludDMyJzogVWludDMyQXJyYXksXG4gICAgJ3VpbnQxNic6IFVpbnQxNkFycmF5LFxuICAgICd1aW50OCc6IFVpbnQ4QXJyYXksXG4gICAgJ3VpbnQ4Y2xhbXBlZCc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgICdpbnQzMic6IEludDMyQXJyYXksXG4gICAgJ2ludDE2JzogSW50MTZBcnJheSxcbiAgICAnaW50OCc6IEludDhBcnJheSxcbiAgICAnZmxvYXQzMic6IEZsb2F0MzJBcnJheSxcbiAgICAnZmxvYXQ2NCc6IEZsb2F0NjRBcnJheVxuICB9O1xuICBpZiAoIXR5cGVzW2RhdGFUeXBlXSkge1xuICAgIHJldHVybiBkYXRhVHlwZTtcbiAgfVxuICByZXR1cm4gbmV3IHR5cGVzW2RhdGFUeXBlXShidWZmZXIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzRGF0YVR5cGUoZGF0YVR5cGUsIGJ1ZmZlcikge1xuICBpZiAoaGFtc3RlcnMuaGFiaXRhdC50cmFuc2ZlcnJhYmxlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NEYXRhKGRhdGFUeXBlLCBidWZmZXIpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGZlZWRIYW1zdGVyKGhhbXN0ZXIsIGZvb2QpIHtcbiAgaWYgKGhhbXN0ZXJzLmhhYml0YXQud29ya2VyKSB7XG4gICAgcmV0dXJuIGhhbXN0ZXIucG9ydC5wb3N0TWVzc2FnZShmb29kKTtcbiAgfVxuICBpZiAoaGFtc3RlcnMuaGFiaXRhdC5pZTEwKSB7XG4gICAgcmV0dXJuIGhhbXN0ZXIucG9zdE1lc3NhZ2UoZm9vZCk7XG4gIH1cbiAgdmFyIGJ1ZmZlcnMgPSBbXSxcbiAgICAgIGtleSA9IHZvaWQgMDtcbiAgZm9yIChrZXkgaW4gZm9vZCkge1xuICAgIGlmIChmb29kLmhhc093blByb3BlcnR5KGtleSkgJiYgZm9vZFtrZXldICYmIGZvb2Rba2V5XS5idWZmZXIpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChmb29kW2tleV0uYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhbXN0ZXIucG9zdE1lc3NhZ2UoZm9vZCwgYnVmZmVycyk7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGhhbXN0ZXJzO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hhbXN0ZXJzLmpzL2J1aWxkL2hhbXN0ZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXG5cdFx0ZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!*********************************!*\
  !*** ./src/interaction/drag.js ***!
  \*********************************/
/*! exports provided: setupDrag */
/*! exports used: setupDrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_waveshaper__ = __webpack_require__(/*! ../core/waveshaper */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_manager__ = __webpack_require__(/*! ../core/manager */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hammerjs__ = __webpack_require__(/*! hammerjs */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hammerjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_hammerjs__);\n\r\n\r\n\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param {WaveShaper} wave \r\n * @param {WaveShapeManager} manager\r\n */\r\nconst setupDrag = function(wave, manager) {\r\n    const canvas = wave.canvas;\r\n    const hammer = new __WEBPACK_IMPORTED_MODULE_2_hammerjs__(canvas);\r\n\r\n    canvas.addEventListener('mouseenter', (e) => {\r\n        if(manager.activeSegment != null && manager.dragWave != null && manager.dragWave.id !== wave.id) {\r\n            const index = manager.dragWave.segments.indexOf(manager.activeSegment);\r\n            manager.dragWave.segments.splice(index, 1);\r\n\r\n            manager.dragWave.flatten();\r\n            manager.draw([manager.dragWave.id], true);\r\n\r\n            wave.segments.push(manager.activeSegment);\r\n            manager.activeSegment.index = 1000;\r\n\r\n            wave.flatten();\r\n            manager.draw([wave.id], true);\r\n\r\n            manager.dragWave = wave;\r\n        } \r\n    });\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const bb = ev.target.getBoundingClientRect();\r\n        const time = (manager.scrollPosition + (ev.center.x - bb.left)) * manager.samplesPerPixel / manager.samplerate;\r\n        const interval = wave.flattened.find(i => i.start <= time && i.end >= time);\r\n\r\n        manager.activeSegment = wave.segments.find(s => s.id === interval.id);\r\n        manager.activeSegment.index = 1000;\r\n        manager.activeSegmentStart = manager.activeSegment.start;\r\n        manager.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('pan', (ev) =>  {\r\n        if(manager.activeSegment == null)\r\n            return;\r\n\r\n        const change = (ev.deltaX * manager.samplesPerPixel) / manager.samplerate;\r\n        manager.activeSegment.start = manager.activeSegmentStart + change;\r\n\r\n        manager.dragWave.flatten();\r\n        manager.draw([manager.dragWave.id], true);\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        manager.activeSegment = null;\r\n        manager.activeSegmentStart = null;\r\n        manager.dragWave = null;\r\n    });\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = setupDrag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW50ZXJhY3Rpb24vZHJhZy5qcz8wNDNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhdmVTaGFwZXIgfSBmcm9tICcuLi9jb3JlL3dhdmVzaGFwZXInO1xyXG5pbXBvcnQgeyBXYXZlU2hhcGVNYW5hZ2VyIH0gZnJvbSAnLi4vY29yZS9tYW5hZ2VyJztcclxuaW1wb3J0ICogYXMgSGFtbWVyIGZyb20gJ2hhbW1lcmpzJztcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGRyYWcgZnVuY3Rpb25hbGl0eSB0byB3YXZlc2hhcGVyXHJcbiAqIFxyXG4gKiBAcGFyYW0ge1dhdmVTaGFwZXJ9IHdhdmUgXHJcbiAqIEBwYXJhbSB7V2F2ZVNoYXBlTWFuYWdlcn0gbWFuYWdlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldHVwRHJhZyA9IGZ1bmN0aW9uKHdhdmUsIG1hbmFnZXIpIHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IHdhdmUuY2FudmFzO1xyXG4gICAgY29uc3QgaGFtbWVyID0gbmV3IEhhbW1lcihjYW52YXMpO1xyXG5cclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKGUpID0+IHtcclxuICAgICAgICBpZihtYW5hZ2VyLmFjdGl2ZVNlZ21lbnQgIT0gbnVsbCAmJiBtYW5hZ2VyLmRyYWdXYXZlICE9IG51bGwgJiYgbWFuYWdlci5kcmFnV2F2ZS5pZCAhPT0gd2F2ZS5pZCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG1hbmFnZXIuZHJhZ1dhdmUuc2VnbWVudHMuaW5kZXhPZihtYW5hZ2VyLmFjdGl2ZVNlZ21lbnQpO1xyXG4gICAgICAgICAgICBtYW5hZ2VyLmRyYWdXYXZlLnNlZ21lbnRzLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICBtYW5hZ2VyLmRyYWdXYXZlLmZsYXR0ZW4oKTtcclxuICAgICAgICAgICAgbWFuYWdlci5kcmF3KFttYW5hZ2VyLmRyYWdXYXZlLmlkXSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICB3YXZlLnNlZ21lbnRzLnB1c2gobWFuYWdlci5hY3RpdmVTZWdtZW50KTtcclxuICAgICAgICAgICAgbWFuYWdlci5hY3RpdmVTZWdtZW50LmluZGV4ID0gMTAwMDtcclxuXHJcbiAgICAgICAgICAgIHdhdmUuZmxhdHRlbigpO1xyXG4gICAgICAgICAgICBtYW5hZ2VyLmRyYXcoW3dhdmUuaWRdLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIG1hbmFnZXIuZHJhZ1dhdmUgPSB3YXZlO1xyXG4gICAgICAgIH0gXHJcbiAgICB9KTtcclxuXHJcbiAgICBoYW1tZXIub24oJ3BhbnN0YXJ0JywgKGV2KSA9PiB7IFxyXG4gICAgICAgIGNvbnN0IGJiID0gZXYudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IHRpbWUgPSAobWFuYWdlci5zY3JvbGxQb3NpdGlvbiArIChldi5jZW50ZXIueCAtIGJiLmxlZnQpKSAqIG1hbmFnZXIuc2FtcGxlc1BlclBpeGVsIC8gbWFuYWdlci5zYW1wbGVyYXRlO1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gd2F2ZS5mbGF0dGVuZWQuZmluZChpID0+IGkuc3RhcnQgPD0gdGltZSAmJiBpLmVuZCA+PSB0aW1lKTtcclxuXHJcbiAgICAgICAgbWFuYWdlci5hY3RpdmVTZWdtZW50ID0gd2F2ZS5zZWdtZW50cy5maW5kKHMgPT4gcy5pZCA9PT0gaW50ZXJ2YWwuaWQpO1xyXG4gICAgICAgIG1hbmFnZXIuYWN0aXZlU2VnbWVudC5pbmRleCA9IDEwMDA7XHJcbiAgICAgICAgbWFuYWdlci5hY3RpdmVTZWdtZW50U3RhcnQgPSBtYW5hZ2VyLmFjdGl2ZVNlZ21lbnQuc3RhcnQ7XHJcbiAgICAgICAgbWFuYWdlci5kcmFnV2F2ZSA9IHdhdmU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBoYW1tZXIub24oJ3BhbicsIChldikgPT4gIHtcclxuICAgICAgICBpZihtYW5hZ2VyLmFjdGl2ZVNlZ21lbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBjaGFuZ2UgPSAoZXYuZGVsdGFYICogbWFuYWdlci5zYW1wbGVzUGVyUGl4ZWwpIC8gbWFuYWdlci5zYW1wbGVyYXRlO1xyXG4gICAgICAgIG1hbmFnZXIuYWN0aXZlU2VnbWVudC5zdGFydCA9IG1hbmFnZXIuYWN0aXZlU2VnbWVudFN0YXJ0ICsgY2hhbmdlO1xyXG5cclxuICAgICAgICBtYW5hZ2VyLmRyYWdXYXZlLmZsYXR0ZW4oKTtcclxuICAgICAgICBtYW5hZ2VyLmRyYXcoW21hbmFnZXIuZHJhZ1dhdmUuaWRdLCB0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGhhbW1lci5vbigncGFuZW5kJywgKGV2KSA9PiB7XHJcbiAgICAgICAgbWFuYWdlci5hY3RpdmVTZWdtZW50ID0gbnVsbDtcclxuICAgICAgICBtYW5hZ2VyLmFjdGl2ZVNlZ21lbnRTdGFydCA9IG51bGw7XHJcbiAgICAgICAgbWFuYWdlci5kcmFnV2F2ZSA9IG51bGw7XHJcbiAgICB9KTtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ludGVyYWN0aW9uL2RyYWcuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n        return Hammer;\n    }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!************************************!*\
  !*** ./src/schedular/schedular.js ***!
  \************************************/
/*! exports provided: Schedular */
/*! exports used: Schedular */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * \r\n * A job schedular that limmits the time it can take up\r\n * in an animationframe by the interval given to it.\r\n * \r\n * This should only be used for jobs that can be dropped if a new\r\n * one arrives before the old is completed. \r\n * \r\n * @param {number} interval ms that jobs are sceduled for each animationframe\r\n * @param {Handle[]} jobs array that jobs are stored in\r\n */\r\nconst Schedular = function(interval, jobs) {\r\n    this.interval =  interval || 16;\r\n    this.jobs = jobs || [];\r\n    \r\n    this.currentJobIndex = 0;\r\n    this.frame = -1; // current animation frame\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Schedular;\n\r\n\r\n/**\r\n * \r\n * Returns a handle that can be used to schedule jobs,\r\n * a single handle should be used for a single repeating task.\r\n * \r\n * @returns {Handle} A scheduling handle\r\n */\r\nSchedular.prototype.getHandle = function() {\r\n    const handle = new Handle();\r\n    this.jobs.push(handle);\r\n}\r\n\r\n/**\r\n * \r\n * Returns an array of handles that can be used to schedule jobs,\r\n * a single handle should be used for a single repeating task.\r\n * \r\n * @param {number} ammount Ammount of handles you want\r\n * @returns {Handle[]} An array of scheduling handles\r\n */\r\nSchedular.prototype.getHandles = function(ammount) {\r\n    var arr = [];\r\n    for(let i = 0; i < ammount; i ++) {\r\n        const handle = new Handle();\r\n\r\n        this.jobs.push(handle);\r\n        arr.push(handle);\r\n    }\r\n    return arr;\r\n}\r\n\r\n/**\r\n * \r\n * Sets the scheduling interval\r\n * \r\n * @param {number} interval\r\n */\r\nSchedular.prototype.setInterval = function(interval) {\r\n    this.interval = interval;\r\n}\r\n\r\n/**\r\n * Call this function to start the schedular\r\n */\r\nSchedular.prototype.start = function() {\r\n    this.frame = requestAnimationFrame(() => this.start());\r\n    if(this.jobs.length === 0) return;\r\n\r\n    const startIndex = this.currentJobIndex;\r\n    const endTime = performance.now() + this.interval;\r\n    while(true || performance.now() < endTime) {\r\n        const job = this.jobs[this.currentJobIndex];\r\n        if(job.hasJob) job.doJob();\r\n\r\n        this.currentJobIndex = ++this.currentJobIndex % this.jobs.length; \r\n        if(this.currentJobIndex === startIndex) break;\r\n    }\r\n}\r\n\r\n/**\r\n * Call this function to stop the schedular\r\n */\r\nSchedular.prototype.stop = function() {\r\n    cancelAnimationFrame(this.frame);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * \r\n * Handles guarentee the schedular processes jobs\r\n * in the order they are requested in while removing jobs\r\n * that have not been completed if addJob is called on the\r\n * same handle before completion.\r\n * \r\n * @param {{() => void}} job\r\n * @param {boolean} hasJob\r\n */\r\nconst Handle = function(job, hasJob) {\r\n    this.currentJob = job || null;\r\n    this.hasJob = hasJob || job != null;\r\n}\r\n\r\n/**\r\n * Cancles a job if it has not been done yet by the schedular\r\n */\r\nHandle.prototype.cancleJob = function() {\r\n    this.hasJob = false;\r\n}\r\n\r\n/**\r\n * Adds a job to the schedular, if the handle had\r\n * an uncompleted job it will be replaced by the new one\r\n * \r\n * @param {() => void} job\r\n */\r\nHandle.prototype.addJob = function(job) {\r\n    this.currentJob = job;\r\n    this.hasJob = true;\r\n}\r\n\r\nHandle.prototype.doJob = function() {\r\n    this.currentJob();\r\n    this.hasJob = false;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NoZWR1bGFyL3NjaGVkdWxhci5qcz8yNWY1Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKipcclxuICogXHJcbiAqIEEgam9iIHNjaGVkdWxhciB0aGF0IGxpbW1pdHMgdGhlIHRpbWUgaXQgY2FuIHRha2UgdXBcclxuICogaW4gYW4gYW5pbWF0aW9uZnJhbWUgYnkgdGhlIGludGVydmFsIGdpdmVuIHRvIGl0LlxyXG4gKiBcclxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGZvciBqb2JzIHRoYXQgY2FuIGJlIGRyb3BwZWQgaWYgYSBuZXdcclxuICogb25lIGFycml2ZXMgYmVmb3JlIHRoZSBvbGQgaXMgY29tcGxldGVkLiBcclxuICogXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBtcyB0aGF0IGpvYnMgYXJlIHNjZWR1bGVkIGZvciBlYWNoIGFuaW1hdGlvbmZyYW1lXHJcbiAqIEBwYXJhbSB7SGFuZGxlW119IGpvYnMgYXJyYXkgdGhhdCBqb2JzIGFyZSBzdG9yZWQgaW5cclxuICovXHJcbmV4cG9ydCBjb25zdCBTY2hlZHVsYXIgPSBmdW5jdGlvbihpbnRlcnZhbCwgam9icykge1xyXG4gICAgdGhpcy5pbnRlcnZhbCA9ICBpbnRlcnZhbCB8fCAxNjtcclxuICAgIHRoaXMuam9icyA9IGpvYnMgfHwgW107XHJcbiAgICBcclxuICAgIHRoaXMuY3VycmVudEpvYkluZGV4ID0gMDtcclxuICAgIHRoaXMuZnJhbWUgPSAtMTsgLy8gY3VycmVudCBhbmltYXRpb24gZnJhbWVcclxufVxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBSZXR1cm5zIGEgaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2NoZWR1bGUgam9icyxcclxuICogYSBzaW5nbGUgaGFuZGxlIHNob3VsZCBiZSB1c2VkIGZvciBhIHNpbmdsZSByZXBlYXRpbmcgdGFzay5cclxuICogXHJcbiAqIEByZXR1cm5zIHtIYW5kbGV9IEEgc2NoZWR1bGluZyBoYW5kbGVcclxuICovXHJcblNjaGVkdWxhci5wcm90b3R5cGUuZ2V0SGFuZGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBjb25zdCBoYW5kbGUgPSBuZXcgSGFuZGxlKCk7XHJcbiAgICB0aGlzLmpvYnMucHVzaChoYW5kbGUpO1xyXG59XHJcblxyXG4vKipcclxuICogXHJcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgaGFuZGxlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNjaGVkdWxlIGpvYnMsXHJcbiAqIGEgc2luZ2xlIGhhbmRsZSBzaG91bGQgYmUgdXNlZCBmb3IgYSBzaW5nbGUgcmVwZWF0aW5nIHRhc2suXHJcbiAqIFxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW1tb3VudCBBbW1vdW50IG9mIGhhbmRsZXMgeW91IHdhbnRcclxuICogQHJldHVybnMge0hhbmRsZVtdfSBBbiBhcnJheSBvZiBzY2hlZHVsaW5nIGhhbmRsZXNcclxuICovXHJcblNjaGVkdWxhci5wcm90b3R5cGUuZ2V0SGFuZGxlcyA9IGZ1bmN0aW9uKGFtbW91bnQpIHtcclxuICAgIHZhciBhcnIgPSBbXTtcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhbW1vdW50OyBpICsrKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gbmV3IEhhbmRsZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmpvYnMucHVzaChoYW5kbGUpO1xyXG4gICAgICAgIGFyci5wdXNoKGhhbmRsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyO1xyXG59XHJcblxyXG4vKipcclxuICogXHJcbiAqIFNldHMgdGhlIHNjaGVkdWxpbmcgaW50ZXJ2YWxcclxuICogXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxyXG4gKi9cclxuU2NoZWR1bGFyLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XHJcbiAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gc3RhcnQgdGhlIHNjaGVkdWxhclxyXG4gKi9cclxuU2NoZWR1bGFyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5mcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnN0YXJ0KCkpO1xyXG4gICAgaWYodGhpcy5qb2JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLmN1cnJlbnRKb2JJbmRleDtcclxuICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSArIHRoaXMuaW50ZXJ2YWw7XHJcbiAgICB3aGlsZSh0cnVlIHx8IHBlcmZvcm1hbmNlLm5vdygpIDwgZW5kVGltZSkge1xyXG4gICAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9ic1t0aGlzLmN1cnJlbnRKb2JJbmRleF07XHJcbiAgICAgICAgaWYoam9iLmhhc0pvYikgam9iLmRvSm9iKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEpvYkluZGV4ID0gKyt0aGlzLmN1cnJlbnRKb2JJbmRleCAlIHRoaXMuam9icy5sZW5ndGg7IFxyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudEpvYkluZGV4ID09PSBzdGFydEluZGV4KSBicmVhaztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBzY2hlZHVsYXJcclxuICovXHJcblNjaGVkdWxhci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZSk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBcclxuICogSGFuZGxlcyBndWFyZW50ZWUgdGhlIHNjaGVkdWxhciBwcm9jZXNzZXMgam9ic1xyXG4gKiBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcmVxdWVzdGVkIGluIHdoaWxlIHJlbW92aW5nIGpvYnNcclxuICogdGhhdCBoYXZlIG5vdCBiZWVuIGNvbXBsZXRlZCBpZiBhZGRKb2IgaXMgY2FsbGVkIG9uIHRoZVxyXG4gKiBzYW1lIGhhbmRsZSBiZWZvcmUgY29tcGxldGlvbi5cclxuICogXHJcbiAqIEBwYXJhbSB7eygpID0+IHZvaWR9fSBqb2JcclxuICogQHBhcmFtIHtib29sZWFufSBoYXNKb2JcclxuICovXHJcbmNvbnN0IEhhbmRsZSA9IGZ1bmN0aW9uKGpvYiwgaGFzSm9iKSB7XHJcbiAgICB0aGlzLmN1cnJlbnRKb2IgPSBqb2IgfHwgbnVsbDtcclxuICAgIHRoaXMuaGFzSm9iID0gaGFzSm9iIHx8IGpvYiAhPSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FuY2xlcyBhIGpvYiBpZiBpdCBoYXMgbm90IGJlZW4gZG9uZSB5ZXQgYnkgdGhlIHNjaGVkdWxhclxyXG4gKi9cclxuSGFuZGxlLnByb3RvdHlwZS5jYW5jbGVKb2IgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaGFzSm9iID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgam9iIHRvIHRoZSBzY2hlZHVsYXIsIGlmIHRoZSBoYW5kbGUgaGFkXHJcbiAqIGFuIHVuY29tcGxldGVkIGpvYiBpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBuZXcgb25lXHJcbiAqIFxyXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGpvYlxyXG4gKi9cclxuSGFuZGxlLnByb3RvdHlwZS5hZGRKb2IgPSBmdW5jdGlvbihqb2IpIHtcclxuICAgIHRoaXMuY3VycmVudEpvYiA9IGpvYjtcclxuICAgIHRoaXMuaGFzSm9iID0gdHJ1ZTtcclxufVxyXG5cclxuSGFuZGxlLnByb3RvdHlwZS5kb0pvYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jdXJyZW50Sm9iKCk7XHJcbiAgICB0aGlzLmhhc0pvYiA9IGZhbHNlO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2NoZWR1bGFyL3NjaGVkdWxhci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ })
/******/ ]);